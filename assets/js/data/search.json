[ { "title": "Effective Java 정리 Item10 [Eqauls는 일반 규약을 지켜 재정의하라]", "url": "/posts/effective-java-item-7/", "categories": "java", "tags": "effectivejava, java", "date": "2023-08-26 09:00:00 +0900", "snippet": "eqauls 메서드는 Object 클래스에 정의되어 있고 기본적으로 동일성(identity) 검사를 하게 됩니다. 즉, 가지고 있는 속성(멤버 변수)가 같아도 객체가 다르면 false를 반환한다는 말입니다. 이 Equals를 재정의 할 때는 고려해야할 것이 많고 구현하고 검증 과정을 반드시 거쳐야 하기 때문에 정말 eqauls를 구현해야 하는 것이 맞는지 고민을 해봐야 합니다. 책에서는 아래 4가지를 생각해보고 한 가지라도 해당이 된다면 Eqauls 메서드를 구현하지 말라고 합니다. 각 인스턴스가 본질적으로 고유하다 인스턴스의 ‘논리적 동치성’을 검사할 일이 없다. 여기서 논리적 동치성이란 동등성(eqauilty)를 말한다. 상위 클래스에서 재정의한 eqauls가 하위 클래스에도 딱 들어맞는다. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다. 생성자가 private이면 이 클래스는 객체로 만들 수 없는 생성자이고 상속또한 할 수 없기 때문에 eqauls 메서드를 부를 일이 없고 pacakge-private 생성자를 가지면서 equals 메서드를 호출할 일이 없다면 eqauls 메서드를 재정의할 필요가 없다.eqauls 메서드는 구현할 때 아래 사항을 지키면서 구현해야 한다. 반사성(reflexity) x.eqauls(x) = true 대칭성(symmetry) if x.eqauls(y) = true, then y.eqauls(x) = true 추이성(transitivity) if x.eqauls(y) = true and y.eqauls(z) = true, then x.eqauls(z) = true 일관성(consistency) if x.eqauls(y) = true, then must x.eqauls(y) = true anytime null-아님(not null) x.equals(null) = false 위 5가지 사항을 지키지 않는다면 equals를 내부적으로 사용하는 라이브러리나 자료구조는 기대하던 대로 동작하지 않을 수 있습니다. 상속의 다형성을 지원하면서 equals 메서드를 재정의하는 방법은 없습니다. 아래를 예시로 든 코드는 세번째 조건 추이성에 위배됩니다.public class ColorPoint extends Point{ private final Color color; public ColorPoint(int x, int y, Color color) { super(x, y); this.color = Objects.requireNonNull(color); } @Override public boolean equals(Object o) { if(!(o instanceof Point)) return false; if(!(o instanceof ColorPoint)) return super.equals(o); return color.equals(((ColorPoint) o).color) &amp;&amp; super.equals(o); }}@Testpublic void transitivityTest() { ColorPoint colorPoint1 = new ColorPoint(1, 2, Color.RED); Point p = new Point(1, 2); ColorPoint colorPoint2 = new ColorPoint(1, 2, Color.BLUE); assertTrue(colorPoint1.equals(p)); assertTrue(p.equals(colorPoint2)); assertFalse(colorPoint1.equals(colorPoint2)); // 추이성 실패}ColorPoint 끼리 비교할 때랑 ColorPoint와 Point를 비교할 때는 비교하는 속성이 다르기 때문에 추이성 테스트가 실패했습니다. 그렇다면 ColorPoint를 아래와 같이 Point와 비교하지 못하게 만들면 어떨가요?@Overridepublic boolean equals(Object o) { if(o == null | o.getClass() != getClass()) return false; // Point랑 비교 못하게 아예 막아버림, LSP 위배 return color.equals(((ColorPointV2) o).color) &amp;&amp; super.equals(o);}이렇게 된다면 추이성 테스트는 통과하겠지만 객체지향 설계원칙(SOLID)중 LSP를 위배하게 됩니다.@Testpublic void LSPTest() { Set&lt;Point&gt; set = Set.of(new Point(1, 2)); ColorPointV2 colorPoint = new ColorPointV2(1, 2, Color.RED); assertFalse(set.contains(colorPoint));}하위 타입은 상위 타입이 수행하던 책임을 수행할 수 있어야 합니다. 하지만 위 코드에서는 ColorPoint가 Point로 수행될 수 있지 않고 무조건 false를 반환하게 될 것 입니다.따라서 상위 타입을 상속한 하위 타입이 속성을 추가한 상태에서는 eqauls 메서드를 재정의 할 수가 없게 됩니다. 그래서 상속의 다형성은 포기하고 컴포지션을 활용해서 eqauls 메서드를 정의하게 되는데요public class ColorPointV3 { private final Color color; private final Point point; public ColorPointV3(int x, int y, Color color) { this.point = new Point(x, y); this.color = Objects.requireNonNull(color); } public Point asPoint() { return this.point; } @Override public boolean equals(Object o) { // 상속을 안함 if(!(o instanceof ColorPointV3)) return false; ColorPointV3 colorPoint = (ColorPointV3) o; return this.color.equals(colorPoint.color) &amp;&amp; point.equals(colorPoint.point); }}이렇게 멤버 변수로 Point를 가지고 있고 이를 eqauls 메서드에서 비교하는데 사용하게 됩니다.책에서 eqauls 메서드를 재정의하는데 가이드라인을 알려줍니다. null이면 false 자신과 비교해서 같은 객체라면 true 타입이 같은지 또는 하위 타입인지 확인, 해당하지 않는다면 false 자신과 같은 타입으로 형변환 멤버 변수 비교 /** * Best Practice */public class PhoneNumber { private final short areaCode, prefix, lineNum; private int hashCode; public PhoneNumber(short areaCode, short prefix, short lineNum) { this.areaCode = areaCode; this.prefix = prefix; this.lineNum = lineNum; } private static short rangeCheck(int val, int max, String arg) { if(val &lt; 0 || val &gt; max) throw new IllegalArgumentException(arg + \": \" + val); return (short) val; } @Override public boolean equals(Object o) { if( o == null) return false; if (o == this) return true; if (!(o instanceof PhoneNumber)) return false; PhoneNumber p = (PhoneNumber) o; return p.areaCode == areaCode &amp;&amp; p.prefix == areaCode &amp;&amp; p.lineNum == lineNum; }} eqauls 메서드를 재정의할 때는 신중해야 하고 책에서 얘기해준 4가지를 떠올려보며 정말 재정의해야하는 상황인지 판단합니다. 그리고 상속을 하면서 멤버변수가 추가된 상황에서는 eqauls를 재정의할 수 없으므로 컴포지트를 이용합니다. eqauls 메서드를 재정의할 때는 가이드라인 대로 만들면 eqauls 일반 규약 5가지를 자연스럽게 지킬 수 있습니다." }, { "title": "객체지향의 사실과 오해 책 후기", "url": "/posts/the-essence-of-object-orientation/", "categories": "Develop Paradigm", "tags": "oop, ddd, responsibility, roles, collaberations", "date": "2023-08-06 09:00:00 +0900", "snippet": "요즘 부서 이동때문에 출퇴근이 4시간이 넘게 걸리네요.. ㅎㅎ 부랴부랴 회사옆에 집은 구했는데 아직 입주까지 2주가 남은 상황이라 조금 더 힘을 내야할듯 합니다. 😅 출퇴근 시간에 읽은 조영호 저자님의 객체지향의 사실과 오해에 대해 후기를 남기려고 합니다. 책 내용 정리보다는 제가 이해한 내용을 바탕으로 글을 쓰려고 합니다.객체지향 프로그래밍은 우리가 실생활에서 인지하고 있는 객체를 소프트웨어에 투영시킴으로써 기억하기 쉽고 이해하기 쉬운 소프트웨어를 만드는데 초점이 맞춰져있습니다. 하지만 실생활의 객체를 그대로 옮긴 것은 아닙니다. 소프트웨어 세상은 현실에 없는 객체도 존재하고 현실세계에서 대부분의 객체는 자율적인 의지가 없어 스스로 행동할 수 없지만 소프트웨어 세상에서 객체는 의지를 갖고 행동할 수 있습니다. 이를 저자는 객체의 의인화가 가능하며 소프트웨어 세상은 실세계를 그대로 옮겨놓은 것이 아닌 은유한 세계라고 설명합니다.역할, 책임 그리고 협력Java 진영 라이브러리들에서 변수, 메서드의 이름이나 설명을 보면 역할, 책임, 협력에 관한 이야기가 많이 나옵니다. 이 3가지 용어가 정확히 무엇을 의미하는지 이 책의 저자가 알려줍니다.책임이란 객체가 메시지를 받았을 때 무엇을 해야 하는지를 나타냅니다. 여기서 어떻게가 아닌 무엇을 결장한다는 것이 중요합니다. 이는 인터페이스와 구현을 분리해 자유로운 객체를 만들 수 있게 해줍니다. 그렇게 되면 클라이언트 코드는 객체의 변경사항에서 자유롭겠죠? 역할은 객체에 책임들이 모여 그 객체가 다른 객체들 사이에서 나타나는 의미를 말합니다. 이런 역할은 일반화/특수화 관계로 추상화 시키면 다른 객체도 그 역할을 대신할 수 있게되면서 객체지향 설계의 수준을 높입니다. 마지막으로 협력은 이런 객체들의 역할이 서로 어우러지면서 사용자가 기대하는 결과나 행동을 수행하는 것을 말합니다. 우리의 최종 목표인거죠. 뒤에 말하겠지만 설계를 할 때는 협력 -&gt; 책임 -&gt; 역할 순으로 고려를 하게됩니다.타입과 클래스타입은 객체의 추상화 방법중 하나로 여러 객체의 구체적인 부분을 하나의 개념으로 표현한 것입니다. 이런 타입을 프로그래밍으로 구현하는 방법 중 하나가 클래스이고 프로토타이핑 언어에서는 프로토타입으로 이를 구현할 수 있다고 합니다. 그리고 설계를 할 때는 하나의 객체가 여러 타입일 수 있고 다른 타입으로 이동하는 경우도 생기지만 대부분의 프로그래밍 언어에서는 단일 분류, 정적 분류만 지원하므로 프로그래밍을 할 때 자연스럽게 다른 객체로 변하게 해야 합니다.도메인 모델과 설계도메인 모델이란 도메인을 표현하는 개념적인 모델이라는 뜻으로 위키피디아에 써있습니다. 이것만 봐서는 무슨 뜻인지 와닿지 않지만 저자가 말해주는 특징을 들어보면 어떤 용도로 쓰이는지 대략 알 수 있습니다. 도메인 모델은 사용자가 시스템에 바라는 목표를 수행할 수 있는 시스템안에 작은 시스템들을 개념적으로 나타낸 것입니다. 예를 들어 커피 주문 도메인에서는 주문, 바리스타, 주문 메뉴, 손님, 커피 등이 있고 손님은 주문을 알고있고 바리스타는 메뉴와 커피를 알고 있겠죠. 이렇게 대략적인 개념 용어와 개념간의 관계에 대해 표현하는 것이 도메인 모델입니다. 이 도메인 모델은 비지니스 로직이 크게 바뀌지 않는 이상 바뀌지 않아야 합니다. 프로그래밍을 하면서 도메인을 수정하는 일은 많이 일어납니다. 하지만 기본적으로 개념과 개념간의 관계는 바뀌는 경우가 없어야 합니다. 그래서 클린 아케텍처나 이를 일반화한 헥사고날 아키텍쳐에서는 도메인 모델을 가장 아래 두어 다른 로직으로 부터 보호하는 아키텍처를 사용합니다. 도메인 모델은 거의 안바뀐다는 가정을 하고 있는 거죠.이런 도메인 모델을 설계하고 난 뒤에는 3가지 방법으로 설계를 합니다. 책임-주도 설계, 디자인 패턴, 테스트-주도 개발 입니다. 먼저 책임-주도 설계는 객체에 주어진 책임에 따라 객채의 상태와 행동이 결정되야 한다는 것입니다. 객체의 상태와 행동은 가장 나중에 결정이 되어야 교체되어도 다른 곳에 영향을 덜 끼칩니다. 그러면 책임은 어디서 부터 나오는 걸까요? 객체가 받은 메시지로 부터 나옵니다. 그리고 메시지는 시스템 책임으로 부터 나오죠. 먼저 시스템 책임을 사용자 유즈케이스에서 추출한 다음 이 시스템 안에 도메인 모델에 있는 개념을 객체로 보고 책임을 수행할 수 있는 객체에게 줄 메시지를 설계하고 책임을 할당합니다. 이 객체가 책임을 수행할 수 없는 객체라고 생각이 되면 수행할 수 있는 객체에게 메시지를 전달해 책임을 전가합니다. 이게 What/Who 사이클이며 끝나면 협력이 완성되는 거죠. 즉, 아래 순서로 시스템의 전반적인 책임,협력 그리고 역할이 설계되는 것입니다.시스템 책임(사용자가 기대하는 것) =&gt; 메시지, 책임(메시지를 먼저 생각하고 이를 수행할 수 있는 객체에게 할당, What/Who 사이클) =&gt; 객체의 상태와 행동을 결정함디자인 패턴은 위 설계 과정을 패턴화 시킨 것입니다. 다른 개발자들이 설계를 해놓은 디자인 패턴을 가져다 쓰면 시간도 절약하고 규모의 경제로 잘 설계되어 있을테니 안정성도 높겠죠. 개발에 적극 활용합니다. 자바 디자인 패턴 레포지토리 테스트-주도 개발은 설계과정이 끝나고 개발을 할 때 객체의 책임을 완벽히 수행하면서 필요없는 로직이 생기지 않게 실패하는 테스트를 짜고 이를 성공시키는 코드를 짠뒤 리펙토링 과정을 거치면서 작동가능한 깔끔한 코드를 만드는 방법입니다. 저자는 핵심은 책임을 객체에 할당하는 설계과정이지 테스트-주도 개발은 이를 도와주는 장치라고 말합니다." }, { "title": "Effective Java 정리 Item6 [불필요한 객체 생성을 피하라]", "url": "/posts/effective-java-item-6/", "categories": "java", "tags": "effectivejava, java", "date": "2023-07-23 09:00:00 +0900", "snippet": "Item6에서는 불필요한 객체를 만들어내는 실수에 대해 다룹니다. 예를 들어, new String(\"bikini\")와 \"bikini\"는 기능적으로 완전히 똑같지만 메모리와 cpu 자원을 낭비합니다. (라고 책에서 말하지만, Java 컴파일러가 잡아서 최적화 시켜줄 거 같습니다 ㅎㅎ) 또한 생성자보단 정적 팩토리 메서드를 사용해서 불필요한 객체 생성을 막는 것도 좋은 습관이 될 거 같습니다. 생성 비용이 비싼 객체는 더욱 중복된 객체가 만들어지는 것에 주의해야합니다. 예를 들어 아래 Pattern객체는 한번 생성될 때 유한 상태 머신도 같이 만들어 지기 때문에 비용이 많이 듭니다.static boolean isRomanNumeralV1(String s) { return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X|[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");}위에는 메서드가 실행될 때마다 Pattern객체를 만듭니다. 아래는 개선된 버전입니다. public class RomanNumerals { private static final Pattern ROMAN = Pattern.compile( \"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X|[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); static boolean isRomanNumeralV1(String s) { return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X|[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); } static boolean isRomanNumeralV2(String s) { return ROMAN.matcher(s).matches(); }}미리 클래스 필드로 패턴객체를 선언해 재사용하는 코드입니다. 제 컴퓨터에서 100번 반복 실행했을 때 5.755 milliseconds와 0.870 milliseconds로 약 7배정도 차이가 나네요.이보다 더 개선하는 방법은 지연 초기화(lazy initialization)이 있는데 추가적인 코드가 들어가고 성능 개선은 크지 않기 때문에 비추천한다고 하네요.불필요한 객체를 만들어내는 또 다른 예는 오토박싱입니다.private static Long sum() { Long sum = 0; for(int i = 0; i &lt; Integer.MAX_VALUE; i++) { sum += i; } return sum;}위 코드는 i가 sum에 더해질 때마다 오토 박싱이 일어납니다. 박싱된 타입보다는 기본 타입을 사용하고 의도치 않게 오토박싱이 숨어들지 않도록 주의해야 합니다. 불필요한 객체 생성때문에 일어나는 성능 저하를 얘기 했지만, 필요한 객체 생성을 하지않는 일은 없어야 합니다. 필요한 객체 생성을 하지않아서 생기는 버그나 보안 구멍은 단순한 성능 저하 문제보다 훨씬 복잡하고 피해가 큽니다. 객체를 생성할 때는 꼭 방어적 복사를 수행하고 불필요한 객체를 선별하는 과정에서 신중합시다" }, { "title": "Effective Java 정리 Item5", "url": "/posts/effective-java-item-5/", "categories": "java", "tags": "effectivejava, java", "date": "2023-07-23 09:00:00 +0900", "snippet": "Item5에서는 정적 유틸리티 클래스나 싱글톤 패턴을 잘못 사용한 예에 대해 설명하면서 의존성 주입을 사용하라고 권고합니다. 예시를 든 코드는 철자 검사기인데 이 철자 검사기 클래스는 정확한 맞춤법이 적혀진 사전을 필드에 가지고 있습니다. 이를 싱글톤이나 유틸리티 클래스로 만들면 하나의 사전만 시스템에서 사용할 수 있습니다. 하지만 현실에선 영어사전도 필요하고, 한국어 사전도 필요한것 처럼 여러 사전이 필요한 상황이 있습니다. 그래서 이 경우에는 싱글톤이나 유틸리티 클래스가 적합하지 않습니다. setter 함수로 바꿔가면서 사용할 수 있지만 이렇게 되면 불변객체가 아니게 되고 멀티 쓰레드 환경에서는 사용하기 어렵습니다. 그래서 처음 객체가 생성될 때 객체를 넘겨 그 객체를 사용하게 만드는 것이 좋습니다.public class SpellCheck { private final Lexicon dictionary; public SpellCheck(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary); }}이 방법을 의존 객체 주입 패턴이라고 부릅니다. 이에 대한 변형이 팩토리 메서드 패턴입니다. 아래와 같이 특정 타입의 인스턴스를 반복해서 만들어 주는 객체(Supplier)를 매개변수로 받고 이를 실행한 결과를 객체로 받는 방법입니다.public class SpellCheckFactoryMethodPattern &lt;E extends Lexicon&gt; { private final E dictionary; public SpellCheckFactoryMethodPattern(Supplier&lt;E&gt; dictionaryFactory) { this.dictionary = Objects.requireNonNull(dictionaryFactory.get()); } public E getDictionary() { return dictionary; }} 클래스 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 내부 동작에 영향을 준다면 싱글톤이나 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서는 안되고 의존 객체 주입 패턴이나 팩토리 메서드 패턴을 쓰자." }, { "title": "Effective Java 정리 Item3", "url": "/posts/effective-java-item-3/", "categories": "java", "tags": "effectivejava, java", "date": "2023-07-23 09:00:00 +0900", "snippet": "item3는 싱글톤 객체를 만드는 방법에 대해 설명합니다. 싱글톤으로 만들면 그 객체를 mocking하기 어려워진다고 합니다. 시스템에 하나의 객체밖에 없도록 설계된 클래스라 mock 객체를 만들기 어렵기 때문입니다. 싱글톤 객체를 만드는 방법은 세가지 입니다. 필드 정적 멤버, 메서드 정적 멤버와 열거타입입니다.필드 정적 멤버public class ElvisV1 { public static final ElvisV1 INSTANCE = new ElvisV1(); public ElvisV1() { }}위 방식의 장점은 첫번째로 간단하다는 것입니다. 따로 접근을 위한 메서드가 필요하지 않습니다. 두번째 장점으로 Reflection을 이용하지 않는다면 싱글톤 객체라는 제약사항을 깨버릴수 없습니다. 처음 시스템이 실행될때 ElvisV1을 초기화 시킬수 있습니다.메서드 정적 멤버public class ElvisV2 { private static final ElvisV2 INSTANCE = new ElvisV2(); public ElvisV2() { } public static ElvisV2 getInstance() { return INSTANCE; }}위 방식은 첫번째보다 더 장점이 많습니다. 첫번째로 설계를 변화시킬 여지가 많다는 것입니다. 추후에 싱글톤 객체 제약사항을 없애고 싶으면 그렇게 바꿔도 클라이언트 코드에는 변경사항이 없습니다. 두번째로 제네릭 싱글톤 펙토리로 만들수도 있습니다. 아래는 List 클래스에서 제네릭 싱긅톤 팩토리가 쓰인 예시입니다.static &lt;E&gt; List&lt;E&gt; of() { return (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;}세번째로는 메서드 참조를 공급자(Supplier)로 사용할 수 있습니다. ElvisV2::getInstance를 Supplier에 사용할 수 있습니다.열거 타입public enum ElvisV3 { INSTANCE;}훨씬 더 간결하고, Reflection 공격과 역직렬화 공격에도 안전합니다. 대부분의 상황에서는 원소가 하나뿐인 열거타입이 싱글톤을 만드는 가장 좋은 방법입니다. 단, 만들려는 싱글톤이 enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없습니다." }, { "title": "Effective Java 정리 Item1", "url": "/posts/effective-java-item-1/", "categories": "java", "tags": "effectivejava, java", "date": "2023-07-15 09:00:00 +0900", "snippet": "안녕하세요. 최근에 Effective Java를 읽으면서 자바의 고급 스킬에 대해 많이 배웠는데요 이를 글로 적어 다시 복습하려고 합니다.item1. 생성자 대신 정적 펙토리 메서드를 고려하라정적 펙터리 메서드는 아래와 같이 private 생성자를 통해 객체를 생성하는 방법입니다.class MyClass { int myField1; String myField2; private MyClass(int myField1, String myField2) { this.myField1 = myField1; this.myField2 = myField2; } public MyClass getInstance(int myField1, String myField2) { return new MyClass(myField1, myField2); }}public 이 정적 펙터리 메서드의 장점은 5가지입니다.장점1. 이름을 가질 수 있다.생성자는 이름을 짓지 못하는데 정적 펙토리 메서드는 이름을 가질 수 있습니다. 이런 이름은 대부분 from, of, valueOf, getInstance 등이 있습니다. 관례적으로 사용하는 이름이 있는데 정리하면 아래와 같습니다. from: 한 개의 매개변수를 받고 객체를 반환하는 형변환 메서드 of: 여러 개의 매개변수를 받고 적합한 타입의 객체를 반환하는 집계 메서드 valueOf: from과 of의 더 자세한 버전 instance 혹은 getInstance: 매개 변수로 명시한 객체를 생성해 반환하지만 매개 변수가 같다고 같은 객체인지는 보장하지 않음 create 혹은 newInstance: instance와 같지만 매번 새로운 객체가 반환됨을 보장함 getType: instance와 같지만 속해 있는 클래스와 다른 클래스를 반환함 Type은 반환하려는 객체의 클래스를 나타냄 newType: getType과 같지만 매번 다른 객체를 반환함을 보장 type: getType과 newType의 간결한 버전2. 호출할 때마다 객체를 새로 생성하지 않아도 됨싱글톤 객체를 만들거나 각 객체의 최대 개수를 지정하고 싶을 때 생성자는 이를 해결하지 못하지만 펙토리 메서드로는 해결할 수 있습니다.3. 반환 타입의 하위 타입 객체를 반환할 수 있음상위 타입의 정적 펙토리 메서드에서 하위타입의 객체를 반환할 수 있습니다. 또한 이는 클라이언트 코드에서는 어떤 하위 타입인지 알지 못하며 이는 클라이언트 코드와 결합도를 낮춰 설계의 자유로움을 가져다 줍니다.4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음3번과 비슷한 내용으로 입력 매개변수에 따라 반환되는 객체의 클래스를 다르게 할 수 있고 이는 다음 릴리즈에 변경해도 클라이언트 코드에는 영향이 없습니다. 예를들어, EnumSet 클래스의 정적 펙토리 메서드는 원소가 64개 이하면 RegularEnumSet을 그보다 초과하면 JomboEnumSet을 반환합니다. 이는 성능적인 이슈 때문이고 나중에 성능 이슈가 해결이되어 하나의 클래스로 수정해야 한다면 자유롭게 수정을 해도 클라이언트 코드를 변경하지 않아도 수정할 수 있습니다.5. 정적 펙토리 메서드를 만들 시점에 반환할 클래스가 존재하지 않아도 됩니다.이건 처음봤을때 무슨 말인지 이해가 가지 않았습니다. 뒤에서 서비스 제공자 프레임워크를 구현할 때 이 개념이 나오게 되는데 이때 책에서 자세히 설명을 해줍니다. 서비스 제공자 프레임워크(Service Provider Framework)는 3개의 핵심 컴포넌트로 이루어 집니다. 등록 API, 서비스 접근 API, 서비스 인터페이스입니다. 이렇게 3개를 구현해 놓으면 서비스 인터페이스를 구현한 다른 클래스를 등록 API로 등록하고 서비스 접근 API를 통해 사용할 수 있습니다. JDBC의 Connection관련 로직인 DriverManager와 Driver가 대표적인 예이고 구현된 코드를 보면 아래와 같습니다.public static void registerDriver(java.sql.Driver driver, DriverAction da) // 등록 API throws SQLException { /* Register the driver if it has not already been added to our list */ if (driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\"registerDriver: \" + driver);}private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException { // 서비스 접근 API ... for (DriverInfo aDriver : registeredDrivers) { // If the caller does not have permission to load the driver then // skip it. if (isDriverAllowed(aDriver.driver, callerCL)) { try { println(\" trying \" + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! println(\"getConnection returning \" + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { println(\" skipping: \" + aDriver.driver.getClass().getName()); } } ...}단점1. 상속을 하려면 public이나 protected인 생성자가 필요한데 정적 팩토리 메서드만 제공하면 만들수 가 없음이에 대한 해결방법은 따로 Types 클래스로(ex, Collections) 정적 펙토리 메서드를 모아서 사용하면 됩니다. 하지만 이는 상속관계보다는 Compostion 관계를 사용하라는 지침을 자연스럽게 따를 수 있고 완전한 불변 객체를 만들기 위해서 지켜야하는 점이라는 것에서 큰 단점은 아닐수 있습니다.2. 사용하려는 클라이언트가 정적 펙토리 메서드를 찾아야 함이는 내가 실무에서도 겪고있는 문제이고 정적 펙토리 메서드를 찾아서 사용해야 하는 점은 불편하긴 합니다. 설계자 입장에서는 Javadoc에 명확히 설명을 적어주고 위에 설명한 정적 펙토리 메서드 이름을 관례적으로 짓는 것으로 클라이언트 프로그래머에게 도움을 줄 수 있습니다.정적 펙토리 메서드와 public 생성자는 장단점이 있으니 적절히 섞어서 사용하되 대부분의 경우에는 정적 펙토리 메서드가 유리하니까 생성자보단 정적 펙토리 메서드를 고려하면서 사용하도록 하는 편이 좋습니다." }, { "title": "왜 제네릭을 쓰는 걸까?", "url": "/posts/why-be-generic-used-in-java/", "categories": "java", "tags": "java, generic, invariance, covariance, contravariance", "date": "2023-02-18 09:00:00 +0900", "snippet": "자바 소스코드를 보다보면 제네릭을 사용한 코드를 많이 볼 수 있습니다. 제네릭에 대해서는 단순 타입을 지정해서 사용하는 것이다 정도만 알고 있으니 해당 코드에 대해 정확히 이해하지 못하고 제가 제네릭을 활용하려 할 때 한계가 있었습니다 그래서 제네릭이 언제 도입되었는지 왜 사용하는지를 나름 정리해서 업무에 활용해보려고 합니다.제네릭을 사용하는 이유제네릭은 다이아몬드 연산자 안에 타입을 입력하면 해당 타입으로 클래스를 사용할 수 있습니다. 자바 컬렉션과 조합이 매우 좋아 대부분의 컬렉션에서 제네릭을 사용했습니다. List&lt;String&gt; list = List.of(\"solana\", \"oopty\", \"lisa\"); list.add(\"alex\");그러면 제네릭은 특정 클래스를 여러 타입으로 사용할 수 있게 재사용하려고 만든 걸까요? 제네릭이 없으면 이런 구현이 불가능 할까요? 그렇지 않습니다. 객체를 Object에 담고 타입 캐스팅으로 바꿔서 사용하면 구현 가능하겠죠 하지만 이렇게 하면 타입 캐스팅을 하는 불편함이 존재하고 타입 캐스팅을 할 때 담긴 객체가 해당 타입과 공변성을 가지지 못한다면 런타임 환경에 에러가 납니다. 이는 실제 운영환경에서 버그가 하나 추가되는 겁니다. 이를 type safety 하지 않다고 하는데 이를 해결한 것이 제네릭입니다.Generic은 언제 나왔을까?제네릭은 2004년에 J2SE 5.0 스펙으로 나왔습니다. 제네릭의 특징은 type removal인데요. type removal는 컴파일 타임에 지정한 타입을 지우고 형변한 연산자로 대체합니다. 이렇게 한 이유는 전 버전과의 호환 때문이라고 하네요 1.4 스펙에서는 아래와 같이 구현을 했고 기존 레거시 코드가 1.5로 넘어올 때 쉽게 넘어올 수 있게 만드려고 했다고 합니다.List zoo = new ArrayList();for (int i = 0; i &lt; zoo.size(); i++) { if (!(zoo.get(i) instanceof Animal)) { continue; } else { Animal animal = (Animal) zoo.get(i); feed(animal); }}자바 Array의 공변성Array는 기본적으로 Type safety하지 않습니다. 타입에 맞지 않은 것을 대입하려 하면 런타임 에러를 발생시키는데요. 예를 들어 아래 코드와 같이 type이 맞지 않는 경우 ArrayStroeException이 일어납니다. (Sub1과 Sub2는 Super의 하위 클래스)Super[] superArray = new Sub1[3];superArray[0] = new Sub2(); // ArrayStoreException컴파일 타임에 이를 알 수 있다면 정말 좋겠죠? 그래서 제네릭은 아래와 같이 제네릭이 다른 타입의 클래스는 상속관계에 상관없이 대입이 불가능하게 만듭니다. 이를 무공변성(invariance)라고 합니다.List&lt;Super&gt; superList = new LinkedList&lt;Sub1&gt;(); // compile error; cannot convert List&lt;Sub1&gt; to List&lt;Super&gt;제네릭에서 공변(covariance)와 반공변(contravariance)를 사용할 수는 없을까?제네릭의 무공변성은 객체지향 프로그래밍의 많은 이점 중 하나인 다형성(polymorphism)을 잃게 됩니다. 너무 많은 걸 잃어버렸네요 ㅜㅜ 그래서 type-safety를 어느정도 지키면서 다형성도 얻을 수 있게 약간 유연성을 줄 수 있습니다. extends와 super 키워드인데요 아래 코드를 보면서 설명하겠습니다.public addToList(List&lt;? extends Super&gt; list) { Super super = list.get(0); list.add(new Super()) // compile error}위 addToList함수는 List&lt;Super&gt;와 Super를 구현한 하위 클래스 타입의 리스트들을(List&lt;Sub1&gt;, List&lt;Sub2&gt;) 매개변수로 받을 수 있습니다.그리고 함수 반환값은 Super객체로 변환됩니다. 매개 변수로 Super 객체를 넘겨주려하면 compile error가 발생합니다. 이렇게 하는 이유는 type-safe를 유지하려고 하기 때문입니다.또 아래와 같이 형변환이 가능한데 이렇게 하면 type-safe하지 않아서 지양합시다.public addToList(List&lt;? extends Super&gt; list) { List&lt;Sub1&gt; sub1List = list; // successfully compiled}T extends Comparable&lt;? super T&gt;Sort 함수를 살펴보면 상당히 복잡하게 생긴 제네릭을 볼 수 있습니다.public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) { list.sort(null);}위 제네릭의 T는 어떻게 해석해야 할 까요? 일단 T extends Comparable 부분은 T가 Comparable을 상속해야한다고 알려줍니다. 만약 상속하지 않았으면 컴파일 에러가 발생합니다. &lt;? super T&gt;는 T의 수퍼클래스 타입의 Comparable 클래스를 말합니다. 이게 왜 필요할까요? 아래와 같이 Super 클래스에서 Comparable을 구현해 놓고 List 객체를 정렬하려 한다면 컴파일이 될까요? class Super implements Comparable&lt;Super&gt; { @Override public int compareTo(Super o) { // 비교 연산 } } // in main method List&lt;Sub1&gt; list = new LinkedList(); Collections.sort(list) // compile error;당연히 안되겠죠 제네릭은 무공변성이니까! 여기서 반공변성을 주고 싶으면 super 키워드를 줘서 &lt;? super T&gt;를 사용한 것 입니다.제네릭을 사용하는 관례제네릭 이름은 아래와 같이 특정 용도에 따라 관례적으로 사용하는 이름이 있으며 꼭 이걸 따를 필요는 없습니다. 그리고 한 글자로 정하는게 대부분이지만 두 글자 이상이어도 상관없다고 합니다. 타입 설명 &lt;T&gt; Type &lt;E&gt; Element &lt;K&gt; Key &lt;V&gt; Value &lt;N&gt; Number " }, { "title": "Java의 공통 메서드", "url": "/posts/java-common-methods/", "categories": "java", "tags": "java, effective java, Object", "date": "2023-01-08 09:00:00 +0900", "snippet": "안녕하세요, 오랜만에 글을 남기는데 회사에서 부서이동도 하고 출장도 갔다오면서 바쁜 나날을 보내 블로그 포스팅은 잠시 접어 두었네요. Effective Java를 읽으면서 내용 정리를 해보려고 합니다. 공부 기록 목적도 있고 복습 차원에서 글을 남기는 점 고려하시고 틀린 내용은 지적 부탁드리겠습니다~!먼저 자바에서 기본 타입이 아닌 모든 객체는 Object를 상속하고 있습니다. 따라서 이 Object가 제공하는 equals, hashCode, toString메서드는 모든 객체가 사용할 수 있습니다.clone, compare 메서드는 각각 Clonable, Comparable 인터페이스를 구현하면 사용할 수 있습니다. 각 메서드를 오버라이드해서 재정의하는 편이 좋은지 아니면 상위 클래스가 구현한 대로 사용하는 편이 좋은지 판단하는 방법을 말씀드릴 겁니다.먼저 equals부터 살펴보겠습니다~eqaulsObject의 eqauls 메서드 구현은 아래와 같습니다.public boolean equals(Object obj) { return (this == obj);}소스 코드에서 보듯이 메모리에 정확히 같이 위치한 객체만이 동일하다고 판단합니다. 이렇게 비교하면 모든 중요 필드를 비교하지 않아도 한번이 비교로 판단할 수 있으니 효과적입니다. 하지만 이렇게 동일성을 비교하는 것이 아닌 동등성을 비교하는 것이라면 아래와 같이 equals 매서드를 오버라이드해서 재정의 해줘야 합니다.public boolean eqauls(Object obj) { if(!obj instaceOf MyClass) return false; MyClass o = (MyClass) obj; return this.field1 == o.field1 &amp;&amp; this.field2 == o.field2; // 중요 필드 비교}이렇게 재정의를 할 때 주의해야할 부분이 있습니다. 바로 eqauls 생성 규칙에 맞아야 하는데요 이걸 지키지 않으면 이를 사용하는 Collection에서 기대하는 대로 동작하지 않을 수 있습니다. reflexive (반사성), x.eqauls(x)는 항상 참이어야 한다. symmetric (대칭성), x.equals(y)가 참일 때만, y.equals(x)가 참이어야 한다 transitive (추이성) 만약 x.eqauls(y)와 y.equals(z)가 참이 라면, x.equals(z)가 참이어야 한다. consistent (일관성) if x.eqauls(y)가 참이거나 거짓이라면 객체 안의 값이 변경되지 않는 한 계속 참이거나 거짓이어야 한다. x.eqauls(null)는 항상 거짓이어야 한다.그리고 상속을 통해 값을 추가하고 equals메서드를 재정의하려고 해서는 안됩니다. 위 5가지를 지키면서 equals메서드를 재정의하는 방법이 없기 때문입니다. 값을 추가하고 싶다면 상속이 아닌 해당 클래스를 필드로 두어서 해결해야 합니다.자바 라이브러리에서도 이를 지키짐 못한 클래스가 있는데 바로 java.util.Date를 확장한 java.sql.Timestamp클래스입니다. nanoseconds필드를 추가해서 eqauls의 대칭성이 위배되었습니다. 그래서 Date 클래스와 같이 쓸 때 주의해야 합니다.equals를 재정의할 때 각 필드마다 어떻게 비교를 해야하는지 팁을 주자면 float와 double을 제외한 기본 타입을 비교할 때는 == 연산자를 사용하고 float와 double은 Float.compare(float, float), Double.compare(double, double)을 사용합니다. 객체는 equals 메서드를 재귀적으로 타면 됩니다.equals 매서드는 동등성 검사를 꼭 해야하는 상황이 아니면 재정의하지 않는 편이 좋다고 합니다. 그리고 재정의 할 때는 위 다섯가지 규칙을 꼭 지켜야 합니다.hashCodeequals를 재정의했다면 hashCode도 재정의를 해야합니다. 그렇지 않다면 아래 코드가 기대와 다르게 동작할 수 있습니다.Map&lt;MyKey, Integer&gt; map = new HashMap();map.put(new MyKey(\"mytest\"), 1);map.get(new MyKey(\"mytest\")); // null을 반환첫번째 객체와 두번째 객체의 hashCode가 다르기 때문에 값이 다른 버킷에 들어가 있고 원하는 결과인 1이 나오지 않습니다.hashCode를 재정의할 때는 아래와 같이 전에 계산했던 해시값에 31을 곱해주면서 반복적으로 값을 계산하는 방식이 대중적입니다. Objects.hash는 느려서 사용을 지양합니다.@Override public int hashCode() { int result = Short.hashCode(field1); result = 31 * result + Short.hashCode(field2); result = 31 * result + Short.hashCode(field3); return result;}그리고 불변 객체라면 hashCode가 바뀌지 않기 때문에 이를 캐싱해 놓을 수 있는데 이 때는 thread-safe하게 작성해야 합니다.@Override public int hashCode() { int result = hashCode; if(result == 0) { int result = Short.hashCode(field1); result = 31 * result + Short.hashCode(field2); result = 31 * result + Short.hashCode(field3); hashCode = result; } return result;}hashCode 반환 값과 만드는 규칙은 최대한 client에게서 감춰야 합니다. 그렇게 해야 client 코드와 상관없이 hashCode를 유연하게 고칠 수 있습니다.toStringtoString은 항상 재정의를 해줘서 디버깅을 쉽게 도와주게 해주는게 좋습니다. 객체가 가진 거의 모든 정보를 반환해주는게 좋고 포맷은 정확히 표시하고 추후 바뀌지 않을 것이라고 확신이 들면 정확한 설명을 해야합니다.그렇지 않다면 “해당 toString의 상세 형식은 정해지지 않았으며 향후 변경될 수 있습니다”라는 문구를 추가해주는 것이 좋습니다./** 상세 형식은 정해지지 않았으며 향후 변경될 수 있습니다.* \"[약물 #9: 유형=사랑, 냄새=내레빈유, 겉모습=먹물]\"*/@Override public String toString() {...}이렇게 하면서 toString의 반환값을 파싱해서 클라이언트가 사용하는 것을 막을 수 있습니다.cloneclone 메서드는 Object 클래스에 명세가 있고 사용 여부는 Clonable 인터페이스 구현으로 제어하는 방식입니다.Clonable 인터페이스를 구현하면 구현한 클래스의 상위 클래스의 clone 메서드를 수정합니다. 상위 클래스의 모든 필드를 복사 후 반환하고 구현하지 않는다면 상위 클래스의 clone 메서드를 호출 시 CloneNotSupportedException을 던집니다. 매우 예외적으로 인터페이스를 사용한 경우라 따라하시면 안됩니다.clone 메서드를 구현할 때는 기존 protected로 되어 있던 접근 제어자를 public으로 바꿔주고 상위 클래스의 clone 메서드를 호출 후 자신의 클래스로 형 변환을 해주어 클라이언트에서 편리하게 사용할 수 있게 해줍니다. 클래스에 추가 필드가 있다면 해당 필드도 복사하는 로직을 넣어줍니다. 그리고 CloneNotSupportedException는 clone을 구현했으므로 try-catch로 묶어서 unchecked exception으로 변환해서 던집니다.(AssertionError)만약 가변 객체를 필드로 가지고 있다면 문제가 복잡해집니다. 해당 가변 객체를 deep copy하는 로직을 직접 작성해야 하며 이로 인해 성능 이슈가 생길 수 있으니 신중히 작성해야 합니다. 그리고 가변 객체 필드를 final로 작성할 수 없어서 모든 가변 객체는 final이어야 한다는 원칙을 위배하는 경우입니다.이펙티브 자바에서 말하기를 clone 메서드 구현보다 복사 생성자나 복사 팩터리를 구현하는게 더 좋은 방법이라고 합니다. 이 경우에는 가변 객체 필드를 final로 선언할 수 있고 불필요한 형변환을 해야할 필요가 없으며 예외 검사를 할 필요도 없습니다.ComparableComparable 인터페이스는 compareTo(T o) 시그니처 형태에 메서드로 객체의 순서를 지정해주는 역할을 합니다. 이는 Collection에서 쓰이기 해서 순서를 고려해야 하는 클래스이면 꼭 작성해야 합니다. compareTo 메서드 일반 규약은 equals 메서드와 비슷합니다. 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 입니다. 추이성으로 보장해야 합니다. x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 이면 x.compare(z) &gt; 0 입니다. 모든 z에 대해 x.compareTo(y) = 0 이면 x.compare(z) = y.compareTo(z) 입니다. 이거는 꼭 지킬 필요는 없지만 권고사항입니다. x.compareTo(y) = 0 이면 x.eqauls(y)는 참입니다. 이를 지키지 않는다면 명시를 해야합니다.네번째 룰을 어긴 것이 BigInteger입니다. 사용할 때 주의가 조금 필요합니다.compareTo를 구현할 때 &gt;, &lt; 같은 관계연산자를 사용하면 에러가 날 수 있으므로 java7 이상을 사용한다면 박싱된 기본 타입의 compare메서드를 이용하셔야 합니다. 이를 이용해서 구현하면 아래와 같은 패턴으로 작성할 수 있습니다.public int compareTo(PhoneNumber pn) { int result = Short.compare(areaCode, pn.areaCode); if (result == 0) { result = Short.compare(prefix, pn.prefix); if (result == 0) result = Short.compare(lineNum, pn.lineNum); } return result;}이를 아래와 같이 Comparator 인터페이스의 비교자 생성 메서드로 구현하면 간단하다.private static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode) .thenComparingInt(pn -&gt; pn.prefix) .thenComparingINt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) { return COMPARATOR.compare(this, pn);}이따금 ‘값의 차’를 이용해 compareTo를 구현하려고 하는 경우가 있습니다. 저도 이렇게 많이 했는데 이러면 정수 오버플로우를 일으켜 추이성이 깨지거나 IEEE 754 부동소수점 계산방식에 의해 오류가 날 수 있습니다. 그래서 아래와 같이 박싱된 기본 타입의 compare 메서드로 구현을 합시다static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() { public int compare(Object o1, Object o2) { return Integer.compare(o1.hashCode(), o2.hashCoe()); }}이렇게 Object 클래스에 있는 기본메서드와 Comparable 인터페이스에 대해 알아보았는데 각 메서드의 일반 규약을 살펴보고 해당 규약에 맞춰 개발해야 한다는게 이번 챕터의 메인 주제였습니다. 이펙티브 자바를 보면서 기존에 제가 작성했던 코드에 대해 생각하게 되고 좀 더 좋은 코드를 작성할 수 있게 제 손가락에 내재화 시켜야겠습니다. 🤔" }, { "title": "Spring Boot와 @WebMVCTest로 MVC Controller를 테스트 하는 방법", "url": "/posts/mvc-testing/", "categories": "spring", "tags": "spring, relectoring, test, mvc, controller, spring boot, fluent API, java, interation test", "date": "2022-07-02 20:14:00 +0900", "snippet": "이 글은 Testing MVC Web Controllers with Spring Boot and @WebMvcTest을 해석하고 정리한 글입니다.이번 글에서는 Controller에 대해 살펴볼 것이다. 먼저 책임 전체를 수용하는 테스트를 작성하기 위해 web Controller가 무엇을 하는지 탐색할 것이다. 그러고 각각 책임을 수용하는 테스트를 작성하는 방법을 찾을 것이다. 이러한 책임이 테스트 되어야지만 Controller가 운영 환경에서 예상대로 동작하는지 확인할 수 있다.이 글은 예제를 제공한다.의존성Junit Jupiter(Junit5)를 사용할 것이고 모킹을 위해 Mockito, 어썰션을 위해 AssertJ와 보일러 플레이트 코드를 줄이기 위해 Lombok을 사용할 거다.dependencies { compile('org.springframework.boot:spring-boot-starter-web') compileOnly('org.projectlombok:lombok') testCompile('org.springframework.boot:spring-boot-starter-test') testCompile 'org.junit.jupiter:junit-jupiter-engine:5.2.0' testCompile('org.mockito:mockito-junit-jupiter:2.23.0')}AssertJ와 Mockito는 spring-boot-starter-test 의존성에서 자연스럽게 들어온다.Web Controller의 책임아래의 전형적인 REST Controller를 보자@RestController@RequiredArgsConstructorclass RegisterRestController { private final RegisterUseCase registerUseCase; @PostMapping(\"/forums/{forumId}/register\") UserResource register( @PathVariable(\"forumId\") Long forumId, @Valid @RequestBody UserResource userResource, @RequestParam(\"sendWelcomeMail\") boolean sendWelcomeMail) { User user = new User( userResource.getName(), userResource.getEmail()); Long userId = registerUseCase.registerUser(user, sendWelcomeMail); return new UserResource( userId, user.getName(), user.getEmail()); }}URL을 정의하고 POST 매핑을 해주는 PostMapping HTTP request를 Deserialze해주는 @PathVariable, @RequestBody등 Spring이 지원해주는 많은 기능들이 있다. Controller를 테스트할 때 이런 것 까지 테스트를 해줘야 할까? 우리가 기대하는 Controller의 책임은 아래와 같다. HTTP Request 요청 수신 Input Deserialization 요청 검증 비지니스 로직 호출 Output Serialization 예외 변환4번을 제외한 나머지 로직은 스프링이 지원해주는 부분이다. 하지만 우리가 Controller에 기대하는 책임이어서 이를 테스트하지 않는다면 운영환경에서 기대하는 대로 동작을 안할 수 있다. 아쉽게도 Unit Test로는 Spring이 지원해주는 부분을 테스트할 수 없다. 따라서 우리는 Spring의 HTTP 지원과 Controller 코드 사이에서 Integration Test를 해야한다.@WebMvcTest로 Controller 책임을 검증하기Spring Boot는 @WebMvcTest 어노세이션을 제공하고 web controller를 테스팅하는데 필요한 빈들만 포함한 application context을 뛰운다.@ExtendWith(SpringExtension.class)@WebMvcTest(controllers = RegisterRestController.class)class RegisterRestControllerTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @MockBean private RegisterUseCase registerUserCase; @Test void whenValidInput_thenReturns200() throws Exception { mockMvc.perform(...); }} @ExtendWith Spring Boot 2.1부터는 SpringExtensio을 로드할 필요가 없다. 왜냐하면 @DataJpaTest, @WebMvcTest와 SpringBootTest와 같은 어노테이션에 이미 메타데이터로 포함되어 있기 때문이다.이제 @Autowired로 모든 필요한 Beans를 가져올 수 있다.또한 @MockBean을 통해 비지니스 로직을 모킹할 수 있다. 우리는 HTTP layer와 controller사이를 통합해서 테스트 하고 싶은거지 비지니스 로직까지 테스트하고 싶은 것은 아니다. 그래서 @MockBean 어노테이션을 통해 applicaiton context안에 있는 빈을 같은 타입의 mock bean으로 교체해 주었다.@MockBean에 대해 더 자세한 글은 이것을 읽어라 @WebMvcTest의 controllers 파라미터의 유무 차이 controller 파라미터를 세팅함으로서 Spring Boot에게 해당 컨트롤러와 필수적인 Spring Web MVC Bean들만 가져오게 한다. 필요할 수도 있는 다른 Bean들은 별도로 포함시키거나 @MockBean으로 모킹시켜야 한다.만약 controller 파라미터를 사용하지 않는다면, 모든 controller들을 application context에 포함시키고 그러므로 모든 Bean들을 가져와야 하니까 테스트 셋업 과정이 복잡하다. 하지만 런타임시 모든 컨트롤러가 같은 application context를 사용하게 되니까 효과적일 수 있다.나는 controller 테스트를 최대한 좁은 applicaiton context로 제한하는 편이다. 비록 Spring Boot가 테스트 마다 새로운 application context를 만들더라도 이렇게 한다.controller의 책임들을 하나씩 보고 최고의 통합 테스트를 작성하기 위해 MockMVC를 사용해서 각각을 검증할 수 있는지 확인하자.1. HTTP Request 매핑controller가 특정 HTTP request에 응답하는지 확인하는 것은 매우 간단합니다. 간단히 MockMVC의 perform() 메서드를 호출하면 됩니다.mockMvc.perform(post(\"/forums/42/register\") .contentType(\"application/json\") .andExpect(status().isOk()))우리는 특정 URL에 controller가 응답하는지, 정확한 HTTP method와 content type을 검증한다. 우리가 작성한 controller는 예제에서 설정한 것과 다른 HTTP request에 대해서는 거부한다.이 테스트는 아직 우리가 input parameter를 넣어주지 않았기 때문에 실패한다.HTTP request Matcher의 옵션에 대해 더 자세히 알고 싶으면 Javadoc을 살펴보아라2. Input DeserializationJava 객체로 성공적으로 Deserialize되는지 확인하려면 Test 코드에서 Input을 제공해줘야 한다. Input은 Reqeust Body의 JSON 형태일 수 있고 URL path안에 있을 수 있고(@PathVariable) HTTP request의 파라미터일 수 있다.(@RequestParam)@Testvoid whenValidInput_thenReturns200() throws Exception { UserResource user = new UserResource(\"Zaphod\", \"zaphod@galaxy.net\"); mockMvc.perform(post(\"/forums/{forumId}/register\", 42L) .contetType(\"application/json\") .param(\"sendWelComeMail\", \"true\") .content(objectMapper.writeValueAsString(user))) .andExpect(status().isOk())}forumId는 path variable로, sendWelcomeMail은 request parameter로 user정보는 request body로 넘겨주었다. request body는 Spring Boot가 제공하는 objectMapper로 객체를 JSON 형식으로 변환해서 넘겨주었다.만약 test가 성공했다면, 우리는 register() 메서드가 이러한 파라미터와 자바 객체를 받고 성공적으로 파싱을 수행했구나라고 생각할 수 있다.3. 요청 검증UserResource 변수에 @NotNull 어노테이션을 적용해 보자.@Valuepublic class UserResource { @NotNull private final String name; @NotNull private final String email; }Bean Validation은 메서드 파라미터에 @Valid 어노테이션을 붙혀주면 자동으로 트리거 된다. 따라서 검증이 성공한 경우에 대한 테스트는 우리가 위에 작성한 테스트 코드로 충분하다.만약 실패하는 경우를 테스트하고 싶다면 검증을 실패하는 UserResource JSON 객체를 controller에 전달하면 된다. 그리고 나서 HTTP status 400을 검증하면 된다.@Testvoid whenNullValue_thenReturns400() throws Exception { UserResource user = new UserResource(null, \"zaphod@galaxy.net\"); mockMvc.perform(post(\"/forums/{forumId}/register\", 42L) ... .content(objectMapper.writeValueAsString(user))) .andExpect(status().isBadRequest());}어플리케이션의 검증이 얼마나 중요한지에 따라, 검증에 실패하는 테스트를 모든 가능한 경우를 만들어야 할 수도 있다. 이것은 빠르게 테스트 케이스가 늘어날 수 있어서 검증 테스트 방법에 대해 팀과 상의를 해본후 결정해야한다.4. 비지니스 로직 호출다음으로, 비지니스 로직이 기대하는대로 호출하는지 검증해보자. 이번 경우에는 비지니스 로직이 RegiesterUseCase 인터페이스에 의해 제공되고 이 함수는 User 객체와 boolean 변수를 기대한다.interface RegisterUseCase { Long registerUser(User user, boolean sendWelcomeMail);}우리는 controller가 User 객체인 UserResource를 regiesterUser() 메서드로 전달하기를 기대한다.이것을 검증하기 위해, application context에 @MockBean을 사용해 모킹된 RegisterUseCase를 사용할 수 있다.@Testvoid whenValidInput_thenMapsToBusinessModel() throws Exception { UserResource user = new UserResource(\"Zaphod\", \"zaphod@galaxy.net\"); mockMvc.perform(...); ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class); verify(registerUseCase, times(1)).registerUser(userCaptor.capture(), eq(true)); assertThat(userCaptor.getValue().getName()).isEqualTo(\"Zaphod\"); assertThat(userCaptor.getValue().getEmail()).isEqualTo(\"zaphod@galaxy.net\");}controller의 함수를 호출한 뒤, ArgumentCaptor를 이용해 RegisterUseCase.registerUser()에 전달되는 User객체를 캡쳐한다. 그리고 기대하는 값을 가지고 있는지 확인한다.verify 호출이 regiesterUser()가 정확히 한번 호출하는지 테스트한다.우리는 User 객체를 검증하는데 많은 assertion을 사용했다. 커스텀 Mockito assertion methods를 사용해서 더 좋은 가독성을 만들 수 있다.5. Output Serialization비지니스 로직이 수행된 후에는 controller가 JSON 형식으로 포함된 결과를 HTTP response에 매핑하는 것을 기대한다. 예제의 경우 HTTP response body에 검증된 UserResource 객체를 JSON 형태로 포함하는지 테스트하면 된다.@Testvoid whenValidInput_thenReturnsUserResource() throws Exception { MvcResult mvcResult = mockMvc.perform(...) ... .andReturn(); UserResource expectedResponseBody = ...; String actualResponseBody = mvcResult.getResponse().getContentAsString(); assertThat(actualResponseBody).isEqualToIgnoringWhitespace( objectMapper.writeValueAsString(expectedResponseBody));}response body를 확인하기 위해, andReturn() 메서드를 이용해 MvcResult 타입의 변수에 HTTP 결과를 저장했다.JSON 결과를 response body에서 읽어 기대값과 isEqualToIgnoringWhitespace()를 사용해 비교해 주었다. 기대값은 Java 객체를 ObjectMapper를 사용해서 JSON 형태로 만들 수 있다.또한 우리는 이것은 커스텀 ResultMatcher를 통해 좀 더 가동석을 높일 수 있다. 뒤에 섹션에서 살펴볼 것이다.6. 예외 변환보통, 예외가 일어난다면, controller는 특정 HTTP status를 반환한다. 예를 들어 Request에 문제가 있다면 400이 반환되고 서버 에러가 발생하면 500이 발생한다.스프링이 대부분의 경우 기본으로 처리한다. 하지만 만약 우리가 커스텀 예외 처리를 하고 있다면 해당 부분을 테스트하기를 원할 것이다. 우리가 JSON 형태의 유효하지 않은 field 이름과 에러 메시지를 반환한다고 하자. 아래와 같이 @ControllerAdvice를 만들었다.@ControllerAdviceclass ControllerExceptionHandler { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseBody ErrorResult handleMethodArgumentNotValidException(MethodArgumentNotValidException e) { ErrorResult errorResult = new ErrorResult(); for (FieldError fieldError : e.getBindingResult().getFieldErrors()) { errorResult.getFieldErrors() .add(new FieldValidationError(fieldError.getField(), fieldError.getDefaultMessage())); } return errorResult; } @Getter @NoArgsConstructor static class ErrorResult { private final List&lt;FieldValidationError&gt; fieldErrors = new ArrayList&lt;&gt;(); ErrorResult(String field, String message){ this.fieldErrors.add(new FieldValidationError(field, message)); } } @Getter @AllArgsConstructor static class FieldValidationError { private String field; private String message; } }만약 Bean 검증이 실패되면 스프링은 MethodArgumentNotValidException을 던질 것이다. 우리는 FieldError 객체를 ErrorResult 객체로 매핑하면서 예외를 처리할 것이다. 이 예외 핸들러는 모든 Controller한테 적용된다.이를 검증하기 위해, 객체 실패 검증 테스트를 확장한다.@Testvoid whenNullValue_thenReturns400AndErrorResult() throws Exception { UserResource user = new UserResource(null, \"zaphod@galaxy.net\"); MvcResult mvcResult = mockMvc.perform(...) .contentType(\"application/json\") .param(\"sendWelcomeMail\", \"true\") .content(objectMapper.writeValueAsString(user))) .andExpect(status().isBadRequest()) .andReturn(); ErrorResult expectedErrorResponse = new ErrorResult(\"name\", \"must not be null\"); String actualResponseBody = mvcResult.getResponse().getContentAsString(); String expectedResponseBody = objectMapper.writeValueAsString(expectedErrorResponse); assertThat(actualResponseBody) .isEqualToIgnoringWhitespace(expectedResponseBody);}Reponse body에서 JSON 결과를 읽고 기대값과 비교한다. HTTP status가 400인지도 확인한다.훨씬 더 가독성이 좋은 방식으로 작성될 수 있다. 아래 챕터을 봐보자커스텀 ResultMatchers 만들기특정 assertion은 쓰기 어려울 뿐더러 읽기도 어렵다. 지난 두 예제 코드에서 살펴봤듯이 HTTP response에서 JSON String을 가져와 기대값과 비교하는 코드는 매우 길다.운이 좋게도, MockMvc의 fluent API를 이용해 커스텀 ResultMatchers을 만들 수 있다.JSON 결과 매칭하기HTTP response body가 자바 객체의 JSON 형식을 포함하고 있는지 검증하기 위해 아래 코드를 사용하는게 좋아 보이지 않나?@Testvoid whenValidInput_thenReturnsUserResource_withFluentApi() throws Exception { UserResource user = ...; UserResource expected = ...; mockMvc.perform(...) ... .andExpect(responseBody().containsObjectAsJson(expected, UserResource.class));}우리는 이제 수동으로 JSON 결과를 비교할 필요가 없다. 그리고 훨씬 가독성이 높아진다. 이 코드는 너무 자명해서 여기서 설명을 그만하겠다.public class ResponesBodyMatchers { private ObjectMapper objectMapper = new ObjectMapper(); public &lt;T&gt; ResultMatcher containsObjectAsJson( Object expectedObject, Class&lt;T&gt; targetClass ) { return mvcResult -&gt; { String json = mvcResult.getResponse().getContentAsString(); T actualObject = objectMapper.readvalue(json, targetClass); assertThat(actualObject).isEqaulToComparingFieldByField(expectedObejct); }; } static ResponseBodyMatchers responseBody() { return new ResponseBodyMatchers(); }}정적 메서드 responseBody()는 fluent API의 진입점을 제공한다. 이것은 HTTP resonse body 에서 JSON을 파싱하는 ResultMatcher을 반환하고 넘겨받은 기대값과 필드 by 필드로 검증한다.기대하는 검증 에러 매칭하기우리는 예외 처리 테스트를 좀 더 간단하게 하기 위해 한 단계 더 나아갈 수 있다. 에러 메세지의 JSO 결과를 검증하기 위해 4 라인이 쓰였다. 아래와 같이 1 라인으로 대체할 수 있다.@Testvoid whenNullValue_thenReturns400AndErrorResult_withFluentApi() throws Exception { UserResource user = new UserResource(null, \"zaphod@galaxy.net\"); mockMvc.perform(...) ... .content(objectMapper.writeValueAsString(user))) .andExpect(status().isBadRequest()) .andExpect(responseBody().containsError(\"name\", \"must not be null\"));}이런 fluent API를 쓰기위해, ResponseBodyMatchers에 containsErrorMessageForField()를 추가해야 한다.public class ResponseBodyMatchers { private ObjectMapper objectMapper = new ObjectMapper(); public ResultMatcher containsError( String expectedFieldName, String expectedMessage) { return mvcResult -&gt; { String json = mvcResult.getResponse().getContentAsString(); ErrorResult errorResult = objectMapper.readValue(json, ErrorResult.class); List&lt;FieldValidationError&gt; fieldErrors = errorResult.getFieldErrors().stream() .filter(fieldError -&gt; fieldError.getField().equals(expectedFieldName)) .filter(fieldError -&gt; fieldError.getMessage().equals(expectedMessage)) .collect(Collectors.toList()); assertThat(fieldErrors) .hasSize(1) .withFailMessage(\"expecting exactly 1 error message\" + \"with field name '%s' and message '%s'\", expectedFieldName, expectedMessage); }; } static ResponseBodyMatchers responseBody() { return new ResponseBodyMatchers(); }}모든 더티 코드는 이 helper class에 숨겨져 있고 우리는 즐겁게 integration test에서 클린 코드를 작성할 수 있다." }, { "title": "가비지 컬렉터 튜닝", "url": "/posts/gc-tuning/", "categories": "java", "tags": "java, jvm, gc, gc tuning", "date": "2022-06-12 02:14:00 +0900", "snippet": "지난 이야기Garbage Collector에 대해 정리해놓은 글에서 Reference &amp; Reachable Object와 Heap 영역의 구조, GC 알고리즘에 대해 설명했습니다. 이번 시간에는 Parallel Collector에 대해 조금 더 설명한 후에 GC 튜닝 방법에 대해 설명하려고 합니다.Parallel Collector (Throughput Collector)Java8에서 default collector입니다. Serial Collector와 비슷하게 동작하지만 차이점은 여러 개의 쓰레드를 가지고 Garbage Collect를 수행해 더 빠르게 동작할 수 있습니다. 멀티 코어나 프로세서환경에서는 이점이 있지만 싱글 코어이거나 힙 사이즈가 100MB 이하인 경우 Serial Collector와 별다른 차이가 없을 수 있습니다. 각 실행환경마다 다르니 많은 테스트를 통해 환경에 맞는 Collector와 파라미터를 찾아야 합니다. -XX:+UseParallelGC위 옵션으로 사용할 수 있습니다.Parallel Collector에서 사용할 수 있는 여러 옵션이 있습니다. 첫번째로 Garbage Collect에 사용할 쓰래드 수를 결정할 수 있습니다.-XX:ParallelGCThreads=&lt;N&gt;항상 N만큼 쓰레드 수를 Garbage Collect에 사용하는 것은 아니고 일정 비율을 곱해 나온 수만큼 사용합니다. 예를 들어 N이 꽤 클 경우(8이상)에는 5/8을 곱합니다.또한 옵션으로 행위 기반 튜닝을 할 수 있습니다. 원하는 목표치를 JVM에게 힌트로 주고 JVM은 내부적으로 통계치를 이용하거나 다른 변수들을 조절해 목표치를 달성합니다. 아래 3가지 목표를 설정할 수 있습니다. 최대 일시 정지 시간 최소화 목표 -XX:MaxGCPauseMillis=&lt;nnn&gt; 너무 낮게 설정하면 전체적인 처리율이 떨어짐 GC가 일시 정지 시간을 예측해서 그에 맞게 Heap 사이즈나 여러 변수들을 조정함 처리율 향상 목표 -XX:GCTimeRatio=&lt;nnn&gt; GC시간과 애플리케이션 시간 비율이 $1\\over1+nnn$으로 설정 Footprint -Xms=&lt;nnn&gt; -Xms=&lt;mmm&gt; 최대 일시 정지 시간, 처리율 향상 목표를 달성한다면 GC는 두 목표중 하나가 실패할 때 까지 Heap사이즈를 줄임 일시 정지 시간 최소화 목표에 의해 Heap 사이즈는 계속 커진 다음에 최대 처리율을 달성하기 위해 계속 Heap사이즈는 줄어듬 이렇게 경쟁적인 목표를 계속 달성하려고 하면서 최적의 값을 찾음 Garbage Collector 튜닝이 필요한 이유모든 프로젝트에 진행할 필요는 없습니다. 하지만 힙 사이즈를 설정했거나 Timeout과 같은 에러메시지가 로그에서 나온다면 튜닝이 필요하다고 할 수 있습니다. 프로그램이 생각보다 많은 메모리를 필요로 하다면 팀의 코딩 스타일을 살펴볼 필요가 있습니다. StringBuffer나 StringBuilder를 활용하지 않고 String으로만 사용한다던지, 매우 큰 용량의 파일을 열어놓고 닫지는 않는다든지 하는 프로그램 로직적인 부분을 먼저 살펴보고 튜닝을 진행해야 합니다. 먼저 말씀드리지만 GC 튜닝은 실험적인 방법으로 최적화를 합니다. 다른 프로젝트에서 좋은 성능을 보였던 옵션이 이번 프로젝트에서는 오히려 낮은 성능을 초래하고 심지어 OutOfMemory 예외를 만날 수도 있습니다.먼저 trade-off 관계인 아래 지표를 봅시다 최대 정지 시간 총 처리율두 지표 모두 힙 사이즈에 큰 영향을 받고 대부분의 상황에서 비례 관계를 갖습니다. 따라서 적당한 값을 어플리케이션의 특성에 맞게 조절해야합니다. 최대 정지 시간을 너무 높게 잡으면 사용자들이 보낸 요청을 STW가 일어나는 동안은 처리할 수 없고 이는 장애로 인식될 수 있습니다. 그렇다고 최대 정지 시간을 낮추려고 힙사이즈를 줄이면 GC가 매우 빈번히 일어날 것이고 Context Switch 비용 때문에 총 처리율이 낮아질 수 있습니다. 이는 최대 동시 접속자 수를 낮추게 될 것이고 원하는 최대 동시 접속자 수만큼 수용이 가능한지 체크해봐야 합니다.Garbage Collector 모니터링 방법jstatjstat은 HotSpot JVM에 있는 모니터링 도구이다. jdk를 설치하면 $JAVA_HOME/bin 디렉토리에 포함되어 있어 jstat으로 바로 실행할 수 있습니다. 각 힙 영역의 최대, 최소 사이즈와 현재 사이즈를 볼 수 있고, 지난 GC의 원인 및 GC 수행 시간을 확인할 수 있습니다. -gcutil(또는 -gccause), -gc, -gccapacity을 가장 많이 사용합니다. 각 컬럼의 뜻은 아래와 같습니다.칼럼\t설명\tjstat 옵션 칼럼 설명 jstat 옵션 S0C Survivor 0 영역의 현재 크기를 KB 단위로 표시 -gc -gccapacity -gcnew -gcnewcapacity S1C Survivor 1 영역의 현재 크기를 KB 단위로 표시 -gc -gccapacity -gcnew -gcnewcapacity S0U Survivor 0 영역의 현재 사용량을 KB 단위로 표시 -gc -gcnew S1U Survivor 1 영역의 현재 사용량을 KB 단위로 표시 -gc -gcnew EC Eden 영역의 현재 크기를 KB 단위로 표시 -gc -gccapacity -gcnew -gcnewcapacity EU Eden 영역의 현재 사용량을KB 단위로 표시 -gc -gcnew OC Old 영역의 현재 크기를 KB 단위로 표시 -gc -gccapacity -gcold -gcoldcapacity OU Old 영역의 현재 사용량을KB 단위로 표시 -gc -gcold PC Permanent영역의 현재 크기를 KB 단위로 표시 -gc -gccapacity -gcold -gcoldcapacity -gcpermcapacity PU Permanent영역의 현재 사용량을KB 단위로 표시 -gc -gcold YGC Young Generation의 GC 이벤트 발생 횟수 -gc -gccapacity -gcnew -gcnewcapacity -gcold -gcoldcapacity -gcpermcapacity -gcutil -gccause YGCT Yong Generation의 GC 수행 누적 시간 -gc -gcnew -gcutil -gccause FGC Full GC 이벤트가 발생한 횟수 -gc -gccapacity -gcnew -gcnewcapacity -gcold -gcoldcapacity -gcpermcapacity -gcutil -gccause FGCT Full GC 수행 누적 시간 -gc -gcold -gcoldcapacity -gcpermcapacity -gcutil -gccause GCT 전체 GC 수행 누적 시간 -gc -gcold -gcoldcapacity -gcpermcapacity -gcutil -gccause NGCMN New Generation의 최소 크기를 KB단위로 표시 -gccapacity -gcnewcapacity NGCMX New Generation의 최대 크기를 KB단위로 표시 -gccapacity -gcnewcapacity NGC New Generation의 현재 크기를 KB단위로 표시 -gccapacity -gcnewcapacity OGCMN Old Generation의 최소 크기를 KB단위로 표시 -gccapacity -gcoldcapacity OGCMX Old Generation의 최대 크기를 KB단위로 표시 -gccapacity -gcoldcapacity OGC Old Generation의 현재 크기를 KB단위로 표시 -gccapacity -gcoldcapacity PGCMN Permanent Generation의 최소 크기를 KB단위로 표시 -gccapacity -gcpermcapacity PGCMX Permanent Generation의 최대 크기를 KB단위로 표시 -gccapacity -gcpermcapacity PGC 현재 Permanent Generation의 크기를 KB단위로 표시 -gccapacity -gcpermcapacity PC Permanent 영역의 현재 크기를 KB단위로 표시 -gccapacity -gcpermcapacity PU Permanent 영역의 현재 사용량을 KB단위로 표시 -gc -gcold LGCC 지난 GC의 발생 이유 -gccause GCC 현재 GC의 발생 이유 -gccause TT Tenuring threshold. Young 영역 내에서 이 횟수만큼 복사되었을 경우(S0 -&gt;S1, S1-&gt;S0) Old 영역으로 이동 -gcnew MTT 최대 Tenuring threshold. Yong 영역 내에서 이 횟수만큼 복사되었을 경우 Old 영역으로 이동 -gcnew DSS 적절한 Survivor 영역의 크기를 KB단위로 표시 -gcnew 위 정보를 jstatd를 통해 원격에서도 볼 수 있고 visual GC를 통해 GUI환경에서 조금 더 직관적이고 쉽게 볼 수 있습니다.JVM Visualjstat은 JVM을 실행할 때 별다른 옵션을 주지않아도 되는 장점이 있지만 GC 수행에 대해서는 간단한 정보만 제공하는 단점이 있습니다. 각 GC의 개별적인 수행 정보를 알고 싶으면 JVM을 실행할 때 -verbosegc 옵션을 주어 얻을 수 있습니다. 이 정보에서 Full GC와 Minor GC가 몇 번 일어났고 수행 전 후의 메모리 사이즈의 변화도 알 수 있습니다. 시각화 툴로는 HPJmeter를 사용할 수 있습니다.튜닝튜닝 절차1. GC 모니터링 결과 분석 후 GC 튜닝 여부 결정jstat이나 jvm의 -verbosegc 설정으로 GC 모니터링을 합니다. GC 모니터링 결과 Full GC가 1초가 넘어가거나 너무 자주 발생한다면 GC 튜닝을 진행해야 합니다. 고려해야하는 것은 young영역과 old영역의 비율, Heap 사이즈, Survivor와 Eden의 비율, Survivor의 Max aging 등이 있습니다.2. GC 방식/메모리 크기 지정 등 파라미터 변경여러 GC 중 적합한 방식의 GC를 선택해서 적용해야 하고 메모리 크기와 비율도 어플리케이션의 특성에 맞춰 변경해야 합니다. 하지만 예상과 다른 전혀 다른 GC와 파라미터가 성능이 좋을 수도 있습니다. GC 튜닝은 실험과학이라는 사실을 기억해야 합니다. 여러 서버에 다양한 파라미터를 적용하고 충분한 시간을 기다려야 합니다.3. 결과가 만족스러울 경우 전체 서버에 반영 및 종료OutOfMemory가 발생하지 않고 성공적으로 원하는 GC 시간과 빈도를 달성했다면 전체 서버에 반영하고 예후를 지켜봅니다.튜닝시 주의할 점튜닝을 하기 전에 메모리 누수나 메모리를 남용하고 있는 코드가 없는지 살펴봐야 합니다. 힙 메모리를 덤프한 후 튜닝 전략을 세우는 것도 좋지만 특정 상황에 치우친 튜닝을 하기 쉽고 서비스의 사용량이 많고 사용자의 패턴이 아주 다양한 경우에는 OutOfMemory 에러나 오히려 GC 소요시간이 길어지거나 빈도가 증가할 수 있습니다. 따라서 실험적인 방법을 통해 경험을 축적하면서 자연 선택적으로(?) 튜닝을 하는 방법을 추천한다고 합니다.출처 NAVER D2: Garbage Collection 모니터링 방법 NAVER D2: Garbage Collection 튜닝 기계인간 John Grib: Java GC 튜닝" }, { "title": "리눅스 헷갈리는 개념 포스팅", "url": "/posts/linux-concept-is-confused/", "categories": "linux", "tags": "linux, chmod, permission, log, man", "date": "2022-03-12 16:54:00 +0900", "snippet": "개발을 하면서 서버의 운영체제는 대부분 리눅스를 사용할 것입니다. 저 또한 리눅스 환경의 서버에 배포하고 운영하고 있으며 서버에 조치사항이 있을 때 터미널로 접근해 해결하고 있습니다. 리눅스의 여러가지 개념 중 헷갈리고 잘 기억되지 않는 것들이 몇 개 있습니다. 파일권한, 데몬 프로세스, Inode 등 리눅스를 사용하는 프로그래머에겐 필수적으로 알아야할 내용이지만 위 개념들 까지 생각하면서 사용하고 있지는 않아 계속 잊어버리는데요. 이번에 글로 정리해놓아 제대로 기억해보려고 합니다.프로세스프로세스란 메모리에 적재되어 실행하고 있는 프로그램을 의미합니다. 제어 터미널(Teletype)에 의해 실행되거나 데몬 프로세스로 실행됩니다. ps -ef를 통해 프로세스를 확인 할 수 있습니다. 위 정보를 통해 프로세스가 어떤 정보를 가지고 있는지 대략 알 수 있습니다. UID는 이 프로세스를 실행시킨 유저의 아이디이고 PID는 프로세스 ID입니다. C는 프로세스 스케줄링에서 CPU사용량을 측정할 때 사용되었지만 지금은 사용하지 않는다고 합니다. STIME은 프로세스 시작시간, TTY는 제어 터미널이고 ?는 제어터미널 없이 실행되는 데몬 프로세스입니다. TIME은 CPU를 사용한 시간이고 CMD는 실행되는 프로그램의 위치를 알려줍니다.foreground 프로세스해당 제어 터미널에서 프로세스를 실행한 뒤, 수행이 종료될 때까지 사용자는 다른 입력을 못하는 프로세스입니다. 현재 터미널에서 실행되고 있는 프로세스 리스트는 jobs를 통해 검색 가능하고 각 작업 번호(job number)와 프로세스 id(pid)가 보입니다. jobs작업 리스트 중 foreground로 실행시키고 싶은 프로세스가 있다면 작업번호로 가져올 수 있습니다. fg [작업 번호]background 프로세스프로세스를 실행한 뒤, 사용자가 다른 입력이 가능하고 실행되는 프로세스입니다. 표준출력은 따로 redirect하지 않는 이상 터미널에 그대로 출력됩니다. background 프로세스 또한 jobs를 통해 조회 가능합니다. 현재 foreground로 실행되고 있는 프로세스를 background로 바꾸고 싶다면 먼저 ctrl+z로 프로세스를 중지하세요. 그러면 중지되고 jobs로 작업을 조회해보면 STOPPED로 표시되어 있을 겁니다. bg와 작업번호로 백그라운드에서 실행할 수 있습니다. bg [작업 번호]또한 프로세스를 시작할 때 끝에 &amp;를 붙혀주면 백그라운드에서 실행합니다.데몬 프로세스백그라운드 프로세스 중 부모 프로세스 id가 1 혹은 다른 데몬 프로세스인 프로세스를 데몬 프로세스라고 합니다. 쉘에서 실행한 백그라운드 프로세스는 부모 프로세스 id를 타고 올라가면 사용자 쉘 프로세스와 연결 되어있습니다. 따라서 사용자가 현재 쉘을 종료하고 나가버리면 해당 프로세스도 종료됩니다. 반면 데몬 프로세스는 부모가 데몬 프로세스이거나 프로세스 id가 1인 init 프로세스이기 때문에 종료되지 않습니다. 만약 백그라운드로 실행시킨 프로세스를 tty를 끊어도 실행시키고 싶다면 nohup 명령을 프로세스 실행명령 앞에 붙이면 됩니다. 데몬 프로세스의 종류는 stand-alone 데몬과 inted 데몬으로 나뉘어집니다.Stand-alone 데몬stand-alone 데몬은 항시 프로세스가 실행 중이며 소켓과 메모리에 상주해 있습니다. 요청이 들어왔을 때 즉각적으로 처리할 수 있어 빠르지만 자원낭비가 있습니다. 자주 요청이 들어오면 서버는 stand-alone으로 띄우는게 좋습니다. /etc/init.d에서 stand-alone 프로세스 구동 스크립트를 확인할 수 있습니다.xinetd 데몬stand-alone으로 띄워져 있는 xinetd 서비스가 들어오는 요청에 따라 적절한 서비스를 띄워 요청을 처리하는 방식입니다. 요청이 들어올 때 마다 프로세스를 올리는 비용이 있어 느리지만 자원 효율성에서 좋습니다. 자주 요청이 들어오지 않는 서버에 적절합니다. /etc/xinetd.conf에 설정파일이 있고, 각 서비스별 설정파일은 /etc/xinetd.d에 따로 둡니다.좀비 프로세스만약 프로세스 실행 중 부모 프로세스나 자식 프로세스가 먼저 종료되면 어떻게 될까요? 부모 프로세스가 먼저 종료된 경우에는 고아 프로세스(Orphan process)가 됩니다. 이런 고아 프로세스는 PPID가 1로 설정되어 종료되지 않고 계속 실행되게 됩니다. (만약 tty 프로세스가 종료된다면 hup시그널로 프로세스 종료) 반대로 자식 프로세스가 먼저 종료된다면 자식 프로세스는 부모 프로세스에게 상태를 알리기 위해 최소한의 자원을 가지고 기다리게 됩니다. 이런 프로세스가 좀비 프로세스(Zombie process)이고 ps aux | grep Z명령어를 통해 확인할 수 있습니다. 이런 경우를 막기 위해 부모 프로세스에서는 wait 시스템 콜로 자식 프로세스를 항상 회수해야 합니다.파일 시스템리눅스에는 다양한 파일 시스템이 있다. 그 중 EXT계열의 파일시스템이 가장 많이 쓰이고 안정성, 속도, 공간 효율성 측면에서 파일시스템마다 차이가 있다. 공통적인 부분에 대해 설명하도록 하겠다. 파일시스템은 디스크를 블록별로 나누고 그 블록을 설명하는 inode라는 개념을 가져온다. inode에는 사용자와 그룹 정보, 권한 정보, 파일 종류에 대한 정보가 있고 해당 파일의 block의 개수와 위치 정보가 있어 알 수 있다. 예를 들어 /home/oopty/test.txt라는 파일을 찾는다고 가정해보자. 루트 디렉토리의 inode는 항상 2번이고 inode 2번의 정보를 보면 루트 디렉토리의 block 번호를 알 수 있다. 해당 block 번호로 가면 루트 디렉토리 하위의 디렉토리와 파일 이름과 inode 번호가 보인다. 그 중 우리는 home이라는 디렉토리의 inode를 찾을 것이고 같은 과정을 반복해서 test.txt 파일을 찾을 것이다. 이 과정이 진행되는 중 디렉토리와 파일의 권한을 확인하면서 진행을 하고 권한이 위배된다면 Permission Denied 예외를 발생할 것이다.디렉토리 구조리눅스에 다양한 배포판이 있지만 디렉토리 구조는 비슷하고 대표적인 디렉토리의 쓰임은 비슷한 거 같다. 그 내용을 정리하겠다. /bin 기본적인 명령어가 있는 디렉토리 root와 일반사용자 모두가 사용할 수 있고 PATH 환경변수에 설정되어 있어 디렉토리 안에 있는 파일들은 파일명만으로 실행할 수 있다. /boot 리눅스 부트로더의 설정파일이 존재하는 곳, 예를 들어 GRUB와 같은 부트로더의 설정파일들이 존재 /dev 디바이스 정보를 저장하는 곳, 여기서 하드디스크의 파티션을 나누고 파일시스템을 만들고 마운트하는 파일들이 존재한다. /etc 시스템 대부분의 설정파일이 존재 /home 사용자의 홈 디렉토리 /lib 커널 모듈 파일과 라이브러리 파일이 있는 곳, 커널이 필요로하는 라이브러리와 모듈이 존재 /media DVD, CD-ROM, USB같은 것들의 마운트 포인트 /mnt 일시적인 마운트를 위한 마운트 포인트 /tmp 공용 임시 디렉토리, 모든 사용자가 공동으로 사용하고 시스템이 주기적으로 청소한다. 해킹의 주요 대상이 되니까 사용하는데는 주의가 필요함 /usr root가 아닌 일반 사용자들이 주로 이용하는 디렉토리 /var 시스템 운용에서 일시적으로 데이터를 생성하거나 로그를 남기는데 사용되는 디렉토리 /lost+found 파일시스템마다 존재할 수 있고 fsck나 e2fsck같은 파일시스템 체크 및 복구 유틸리티 실행 후에 생성이 되는 것, 시스템의 오류나 강제종료로 인해 생성되는 파일들이고 시스템 부팅시 파일 시스템 체크 유틸리티가 속한 디렉토리가 없는 파일들을 여기에 모아 놓는다. 출처 POSIX 알아보기 #1: LINUX(리눅스) 파일시스템의 종류와 특징 리눅스 디렉토리 구조" }, { "title": "스프링 부트 검증 완벽 가이드", "url": "/posts/validation-with-spring-boot/", "categories": "java, spring", "tags": "java, spirng, validation", "date": "2022-03-12 16:54:00 +0900", "snippet": "스프링 부트 예외처리 완벽 가이드에 이어 스프링 부트에서 지원하는 검증 방법을 배우고 예시를 들며 설명하려고 합니다. Validation with Spring Boot - the Complete Guid를 번역했습니다.Bean Validation은 자바 생태계에서 검증 로직 구현의 사실상 기준이다. 스프링과 스프링 부트와 잘 통합된다.하지만, 몇가지 주의할 점이 있다. 이번 튜토리얼에선 모든 검증 사용 사례와 스포츠 코드 예제를 통해 각각 살펴본다.Example Code이 기사는 Github에 예제코드를 포함하고 있다.Spring Boot Validation Starter스프링 부트의 검증은 validation starter로 사용할 수 있고 이것은 Gradle으로 프로젝트에 포함할 수 있다.implementation('org.springframework.boot:spring-boot-starter-validation')Spring Dependency Management Gradle Plugin덕분에 버전을 명시할 필요는 없다. 만약 플러그인을 사용하고 있지 않다면, 최신 버전을 여기에서 찾을 수 있다.Bean Validation Basics기본적으로, 빈 검증은 검증 어노테이션으로 클래스 필드에 제한을 정의하므로써 작동된다.일반적인 검증 어노테이션몇가지 가장 일반적인 어노테이션은 아래와 같다 @NotNull: 필드는 null이면 안된다. @NotEmpty: 리스트 필드는 비어있으면 안된다. @NotBlank: string 필드는 빈 스트링이 아니어야 한다. (즉, 적어도 글자 하나가 있어야 한다.) @Min and @Max: numeric 필드는 특정 값 이상거나 이하여야 한다. @Pattern: string 필드는 특정 정규표현식을 만족해야 한다. @Email: sring 필드는 이메일 형식이어야 한다.class Customer { @Email private String email; @NotBlank private String name; // ...}Validator오브젝트가 유효한 지 검사하기 위해서는 Validator에 전달한다.Set&lt;ConstraintViolation&lt;Input&gt;&gt; violations = validator.validate(customer);if (!violations.isEmpty()) { throw new ConstraintViolationException(violations);}@Validated and @Valid그렇지만 많은 경우에는 스프링이 검증을 해준다. 우리는 validator 오브젝트를 만들 필요가 없고 대신 스프링에게 유효한 오브젝트가 필요한 것을 알려주면 된다. 이것은 @Validated와 @Valid 어노테이션을 통해 작동된다.@Validated 어노테이션은 class-level 어노테이션이다. 스프링은 메서드로 넘겨지는 파라미터를 검증해준다. 후에 더 자세히 다뤄볼 것이다.메서드 파라미터와 필드에 @Valid 어노테이션을 붙힐 수 있다. 스프링은 메서드 파라미터와 필드를 검증해준다. 이것 또한 후에 더 자세히 살펴볼 것이다.Spring MVC Controller의 입력 거증우리가 REST Contoller를 구현했고 클라이언트에게 오는 입력들을 검증하기 원한다고 하자. HTTP request로 오는 세가지 검증 사항들이 있다. Request Body Path variables query paramtersRequest Body 검증POST와 PUT request에서는 request body에 json 페이로드를 넣는 경우가 많다. 스프링은 자동으로 Java 오브젝트로 바꿔준다. 자 이제, 우리는 이 Java 오브젝트를 검증하기를 원한다.아래가 입력 페이로드 클래스이다.class Input { @Min(1) @Max(10) private int numberBetweenOneAndTen; @Pattern(regexp = \"%[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}$\") private String ipAddress; // ...}numberBetweenOneAndTen은 1이상 10이하인 수를 가질 수 있고 ipAddress는 IP Address 형식에 맞는 문자열을 가질 수 있다.(IP Address는 각 클래스마다 255이하의 숫자만 가능하고 이에 대한 검증은 custome validator를 통해 뒤에서 구현할 것이다)HTTP request body를 검증하기 위해 REST Controller의 request body에 @Valid 어노테이션을 붙여준다.@RestControllerclass ValidateRequestBodyController { @PostMapping(\"/validateBody\") ResponseEntity&lt;String&gt; validateBody(@Valid @RequestBody Input input) { return ResponseEntity.ok(\"valid\"); }}Path Variables과 Request Parameters 검증path variables과 request paramters 검증은 약간 다르게 동작한다.복잡한 자바 오브젝트를 검증하지 않는다. path variables과 request parameters는 primitive type이나 Integer, String같은 counterpart object이기 때문이다.위 처럼 클래스 필드에 어노테이션을 적용하는 대신, 스프링 컨트롤러에서 메서드 파라미터에 직접적으로 어노테이션을 사용한다. (아래 경우에는 @Min)@RequestController@Validatedclass ValidateParametersController { @GetMappling(\"/validatePathVariable/{id}\") ReponseEntity&lt;String&gt; validatePathVariable( @PathVariable(\"id\") @Min(5) int id) { return ResponseEntity.ok(\"valid\"); } @GetMapping(\"/validateRequestParamter\") ResponseEntity&lt;String&gt; validateRequestParamter( @RequestParam(\"param\") @Min(5) int param) { return ResponseEntity.ok(\"valid\"); }}스프링이 메서드 파라미터에 검증 어노테이션을 평가하기 위해 class-level에서 컨틀롤러에 @Validated 어노테이션을 추가했다.@Validated는 메서드에 사용할 수 있어도 이 경우에서는 오직 class-level에서만 평가된다. (왜 method-level에서 사용가능한지는 후에 논의하겠다.)request body 검증과는 다르게 검증이 실패하면 MethodArgumentNotValidException대신 ConstraintValidationException을 던진다. 스프링은 이 예외에 대해 디폴트 핸들러를 등록하지 않는다. 따라서 기본적으로 HTTP status 500(Internal Server Error)을 날린다.만약 HTTP status 400(Bad Request)을 날리고 싶다면, 우리는 커스텀 예외 핸들러를 컨트롤러에 추가할 수 있다.@RestController@Validatedclass ValidateParametersController{ //request mapping method omitted @ExceptionHandler(ConstraintViolationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) ResponseEntity&lt;String&gt; handleContraintViolationException(ConstraintViolationException e) { return new ResponseEntity&lt;&gt;(\"not valid due to validation error: \" + e.getMessage(), HttpStatus.BAD_REQUEST); }}튜토리얼에서 어떻게 모든 실패 검증에 대한 설명을 포함한 구조화된 에러 응답을 보내는지 볼것이다.통합 테스트로 검증 동작을 실증할 수 있다.@ExtendWith(SpringExtension.class)@WebMvcTest(controllers = ValidateParamtersController.class)class ValidateParamtersConrollerTest { @Autowired private MockMvc mvc; @Test void whenPathVariableIsInvalid_thenReturnStatus400() throws Exception { mvc.perform(get(\"/validatePathVariable/3\")) .andExpect(status().isBadRequest()); } @Test void whenRequestParameterIsInvalid_thenReturnsStatus400() throws Exception { mvc.perform(get(\"/validateRequestParameter\") .param(\"param\", \"3\")) .andExpect(status().isBadRequest());}스프링 Service 메서드의 입력 검증컨트롤러 레벨에서 입력을 검증하는 대신, 어떤 스프링 컴포넌트에 입력을 검증할 수 있다. 그러기 위해, @Validated와 @Valid 어노테이션을 조합해서 사용한다.@Service@Validatedclass ValidatingService{ void validateInput(@Valid Input input) { //do something }}다시 말하지만, @Validated 어노테이션은 class-level에서만 평가되기 때문에 메서드에 붙이지 않는다.아래는 검증 동작 실증이다.@ExtendWith(SpringExtension.class)@SpringBootTestclass ValidatingServiceTest { @Autowired private ValidatingService service; @Test void whenINputIsInvalid_thenThrowsException() { Input input = invalidInput(); assertThrows(ConstraintViolationException.class, () -&gt; { service.validateInput(input) }); }}JPA Entities 검증검증을 위한 마지막 방어선은 persistence layer이다. Spring Data는 빈 검증을 바로 사용할 수 있는 Hibernate를 아래에 사용하고 있다. Persistence layer에서 검증을 하는게 옳은 방법 일까? 우리는 일반적으로 persisten layer처럼 늦게 검증을 하지 않는다. 왜냐하면 위에 비지니스 코드는 유효하지 않은 오브젝트로 동작할 수 있다는 말이다. 이것은 예기치 못한 에러를 만들 수 있다.Input 클래스를 데이터베이스에 저장해보자. 첫번째로 필수적인 JPA 어노테이션 @Entity와 ID 필드를 추가한다.@Entitypublic class Input { @Id @GeneratedValue private Long id; @Min(1) @Max(10) private int numberBetweenOneAndTen; @Pattern(regexp = \"^[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}$\") private String ipAddress; // ...}그리고나서 Spring Data 레포지토리를 만든다.public interface ValidatingRepository extends CrudRepository&lt;Input, Long&gt; {}기본적으로, 우리가 유효하지 않은 Input 오브젝트를 저장할 때마다 ContraintViolationException을 얻는다. 아래 통합 테스트를 보자.@ExtendWith(SpringExtension.class)@DataJpaTestclass ValidatingRepositoryTest { @Autowired private ValidatingRepository repository; @Autowired private EntityManager entityManager; @Test void whenInputIsInvalid_thenThrowsException() { Input input = invalidInput(); assertThrows(ConstraintViolationException.class, () -&gt; { repository.save(input); entityManager.flush(); }); }}Spring Data 레포지토리 테스트에 대해서는 여기에서 더 자세히 볼 수 있다.빈 검증은 EntityManager가 플러쉬될때 마다 Hibernate에 의해 트리거된다. Hibernate는 특정 환경에서 EntityManager를 플러시하지만 이 통합 테스트에서는 직접 해줘야 한다.만약 어떤 이유에서 Spring Data 레포지토리에서 빈 검증을 비활성하고 싶다면, Spring Boot 속성 중 spring.jpa.properties.javax.persistence.validation.mode을 none으로 설정한다.커스텀 Validator사용가능한 contrain 어노테이션이 우리 사용 사례에 충분치 않다면, 우리 스스로 만들어야 한다.Input 클래스에서는 정규표현식을 통해 IP Address를 검증하지만 완벽하지 않다. 255 이상인 숫자도 허용하기 때문이다. (다시말해, “111.111.111.333”이 유효하다)정규 표현식 대신 자바에서 검증하는 validator를 구현하므로 해결해보자. (더 복잡한 정규표현식을 사용해 해결할 수도 있다.)첫번째로, 커스텀 contraint 어노테이션 Ipaddress를 생성한다.@Target({ FIELD })@Retention(RUNTIME)@Contraint(validateBy = IpAddressValidator.class)@Documentedpublic @interface IpAddress { String message() default \"{IpAddress.invalid}\"; Class&lt;?&gt;[] groups() default { }; Class&lt;? extends Payload&gt;[] payload() default { };}커스텀 contraint 어노테이션은 아래와 같은 것들이 필요하다. 파라미터 message, 검증 시패시 메시지를 해결하는데 사용되는 ValidationMessage.properties의 키를 가르킨다. 파라미터 groups, 어느 환경에서 이 검증이 동작될 지 정의하게 해준다. 파라미터 payload, 검증과 함께 넘겨지는 페이로드를 정의하게 해준다. 그리고 @Contraint 어노테이션은 ContrainValidator 인터페이스의 구현체를 가르킨다.Validator 구현체는 아래와 같다.class IpAddressValidator implements ConstraintValidator&lt;IpAddress, String&gt; { @Override public boolean isValid(String value, ConstraintValidatorContext context) { Pattern pattern = Pattern.compile(\"^([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})$\"); Matcher matcher = pattern.matcher(value); try { if (!matcher.matches()) { return false; } else { for (int i = 1; i &lt;= 4; i++) { int octet = Integer.valueOf(matcher.group(i)); if (octet &gt; 255) { return false; } } return true; } } catch (Exception e) { return false; } }}constraint 어노테이션과 같이 @IpAddress 어노테이션을 사용할 수 있다.class InputWithCustomValidator { @IpAddress private String ipAddress; // ...}프로그래밍적으로 검증스프링 built-in 빈 검증 지원에 의존하기 보다 프로그래밍적으로 검증르 하고싶을 때가 있다. 이 경우 빈 검증 API를 직접적으로 사용할 수 있다.Validator을 직접 만들고 검증하기 위해 실행한다.class ProgrammaticallyValidatingService { void validateInput(Input input) { ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); Validator validator = factory.getValidator(); Set&lt;ConstraintViolation&lt;Input&gt;&gt; violations = validator.validate(input); if (!violations.isEmpty()) { throw new ConstraintViolationException(violations); } } }스프링 지원이 전혀 필요하지 않다.그렇지만, 스프링은 미리 설정된 Validator를 지원한다. 우리는 직접 만드는 대신 우리 서비스에 이 객체를 주입하고 사용할 수 있다.@Serviceclass ProgrammaticallyValidatingService { private Validator validator; ProgrammaticallyValidatingService(Validator validator) { this.validator = validator; } void validateInputWithInjectedValidator(Input input) { Set&lt;ConstraintViolation&lt;Input&gt;&gt; violations = validator.validate(input); if (!violations.isEmpty()) { throw new ConstraintViolationException(violations); } }}이 서비스가 스프링에 의해 초기화될 때, 생성자에 의해 주입된 Validator를 가지게 될 것이다.다음 코드는 두가지 메서드가 기대하는 대로 동작되나 확인한다.@ExtendWith(SpringExtension.class)@SpringBootTestclass ProgrammaticallyValidatingServiceTest { @Autowired private ProgrammaticallyValidatingService service; @Test void whenInputIsInvalid_thenThrowsException(){ Input input = invalidInput(); assertThrows(ConstraintViolationException.class, () -&gt; { service.validateInput(input); }); } @Test void givenInjectedValidator_whenInputIsInvalid_thenThrowsException(){ Input input = invalidInput(); assertThrows(ConstraintViolationException.class, () -&gt; { service.validateInputWithInjectedValidator(input); }); }}Validation groups를 이용해 다른 사용 유형에 따라 다르게 검증하기종종, 어떤 객체는 여러 다른 사용사례들에서 공유한다.CRUD 동작에 대해 얘기해보자, 예를 들어 Create과 Update는 대게 같은 객체를 입력으로 사용할 것이다. 그렇지만 다른 환경에서 다르게 작동되야 하는 검증이 있다. 오직 “Create”일 때만 오직 “Update”일 때만 두 가지 경우 일 때검증 룰을 구현하게 해주는 빈 검증 기능은 “Validation Groups”라고 불린다.우리는 이미 커스텀 어노테이션을 구현하면서 contraint 어노테이션은 groups필드를 가지고 있어야 하는 것을 보았다. 이것은 트리거되야 하는 Validation Group을 정의한 클래스를 넘기는데 사용된다.CRUD 예제에서는 OnCreate과 OnUpdate 마커 인터페이스를 정의한다.interface OnCreate {}interface OnUpdate {}마커 인터페이스는 contraint 어노테이션에 아래와 같이 사용할 수 있다.class InputWithGroups { @Null(groups = OnCreate.class) @NotNull(groups = OnUpdate.class) private Long id; // ... }이것은 ID가 “Create”으로 사용할 때는 비어있어야 하고 “Update”일 때는 비어있으면 안된다는 것을 말한다.스프링은 Validation Groups를 @Validated 어노테이션으로 제공한다.@Service@Validatedclass ValidatingServiceWithGroups { @Validated(OnCreate.class) void validateForCreate(@Valid InputWithGroups input){ // do something } @Validated(OnUpdate.class) void validateForUpdate(@Valid InputWithGroups input){ // do something }}클래스에도 @Validated 어노테이션이 붙은 것을 확인해라. 어느 Validation Groups가 활성화 되었는지 정의하기 위해 method-level에도 붙여야 한다.아래는 테스트다.@ExtendWith(SpringExtension.class)@SpringBootTestclass ValidatingServiceWithGroupsTest { @Autowired private ValidatingServiceWithGroups service; @Test void whenInputIsInvalidForCreate_thenThrowsException() { InputWithGroups input = validInput(); input.setId(42L); assertThrows(ConstraintViolationException.class, () -&gt; { service.validateForCreate(input); }); } @Test void whenInputIsInvalidForUpdate_thenThrowsException() { InputWithGroups input = validInput(); input.setId(null); assertThrows(ConstraintViolationException.class, () -&gt; { service.validateForUpdate(input); }); }} Validation Groups 조심해서 사용 Validation Groups를 사용하는 것은 관점이 섞이기 때문에 쉽게 안티 패턴이 될 수 있다. Validation Groups와 함께 사용되는 엔티티는 모든 사용 케이스에 대해 검증 규칙을 알아야 한다. Bean Validation anti-patterns 토픽에서 더 자세히 설명한다.검증 에러 핸들링검증이 실패하면 의미있는 에러메시지를 클라이언트에게 전달하고 싶다. 각각 검증 실패에 대해 에러메시지를 포함한 데이터를 전달해야한다.첫째로, 우리는 데이터 구조체를 정의할 것이다. ValidationErrorResponse라고 명명할 것이고 이건 Violation 오브젝트 리스트를 포함한다.public class ValidationErrorResponse { private List&lt;Violation&gt; violations = new ArrayList&lt;&gt;(); // ...}public class Violation { private final String fieldName; private final String message; // ...}그러고나서 controller-level까지 올라오는 모든 ConstraintViolationExceptions를 다룰 전역 @ControllerAdvice를 만든다. request body에서 일어나는 검증 에러도 잡기 위해 MethodArgumentNotValidExceptions에 대한 핸들러도 만든다.@ControllerAdviceclass ErrorHandlingControllerAdvice { @ExceptionHandler(ConstraintViolationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody ValidationErrorResponse onConstraintValidationException( ConstraintViolationException e) { ValidationErrorResponse error = new ValidationErrorResponse(); for (ConstraintViolation violation : e.getConstraintViolations()) { error.getViolations().add( new Violation(violation.getPropertyPath().toString(), violation.getMessage())); } return error; } @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody ValidationErrorResponse onMethodArgumentNotValidException( MethodArgumentNotValidException e) { ValidationErrorResponse error = new ValidationErrorResponse(); for (FieldError fieldError : e.getBindingResult().getFieldErrors()) { error.getViolations().add( new Violation(fieldError.getField(), fieldError.getDefaultMessage())); } return error; }}결론이 튜토리얼에서 스프링 부트로 어플리케이션을 구축할 때 필요한 주요 검증 기능들을 훑어봤다. 예제 코드도 준비되어 있으니, 직접 타이핑해보자" }, { "title": "스프링 부트 예외처리 완벽 가이드", "url": "/posts/complete-guide-to-exception-handling-in-spring-boot/", "categories": "java, spring", "tags": "excpetion handling, spring, java, controlleradvice, anotation", "date": "2022-01-16 21:40:00 +0900", "snippet": "회사에서 Spring Boot 관련 프로젝트를 진행하면서 스프링에서 지원하는 어노테이션 스펙이 궁금했고 우리 프로젝트엔 어떻게 적용되어 있는지 살펴보고 싶었다. 때마침 기술관련된 내용을 잘 정리한 사이트를 찾아서 예외처리 관련된 주제를 번역하면서 정리하려고 합니다. 아래 내용은 Complete Guide to Exception Handling in Spring Boot에 있던 내용을 제가 이해한 수준으로 번역한 결과입니다.예외 처리는 탄탄한 어플리케이션을 만드는데 중요한 부분을 차지합니다. 스프링 부트에선 여러가지 방법을 제시합니다. 이 글에선 여러가지 방법을 시험해보고 다른 방법보다 더 선호되는 방법이 있을 땐 제안도 드릴겁니다.예시 코드이 글은 GitHub에 있는 동작 코드를 제공합니다.소개스프링 부트는 단순한 try=catch를 넘어선 예외처리 도구를 제공합니다. 이러한 도구를 이용하기 위해 우리는 관점을 분리로서 예외처리를 다루는 몇가지 어노테이션을 사용합니다. @ResponseStatus @ExceptionHandler @ControllerAdvice어노테이션들을 보기 전에 우리는 먼저 스프링이 어떻게 웹 컨트롤러에서 던저진 에러를 처리하는지 살펴볼것입니다 - 에러를 처리하는 마지막 단계또한 기본 설정을 바꾸기위해 스프링 부트에서 제공하는 몇가지 설정도 살펴볼 예정입니다.우리가 예외를 처리하면서 겪는 어려움을 인지하고나서 우리는 어노테이션으로 해결할 겁니다.스프링 부트 기본 예외처리 메커니즘주어진 id가 없을 때 NoSuchElementException 런타임 에러를 던지는 getProduct 메서드를 가지고 있는 ProductController가 있다고 가정해봅시다.@RestController@RequestMapping(\"/product\")public class ProductController { private final ProductService productService; //constructor omitted for brevity... @GetMapping(\"/{id}\") public Response getProduct(@PathVariable String id){ // this method throws a \"NoSuchElementFoundException\" exception return productService.getProduct(id); } }우리가 유효하지 않은 id로 /product API를 호출하면 NoSuchElementFoundException 런타임 에러를 발생시킬거고 다음 Response를 얻게될 겁니다.{ \"timestamp\": \"2020-11-28T13:24:02.239+00:00\", \"status\": 500, \"error\": \"Internal Server Error\", \"message\": \"\", \"path\": \"/product/1\"}페이로드는 올바른 형식의 에러 메시지 외에 어떤 정보도 주지 않습니다. 심지어 message필드는 비어있지만 우리는 “Item with id 1 not found”같은 것을 포함하길 기대합니다.이 에러 메시지 이슈를 고쳐봅시다.스프링 부트는 우리가 에러 메시지, 에러 클래스 또는 Response 페이로드의 스택 트레이스 일부를 더할 수 있는 몇가지 속성을 제공합니다.server: error: include-message: always include-binding-errors: always include-stacktrace: on_trace_param include-exception: false스프링 부트 서버 속성을 사용하면 에러 메시지를 어느 정도 바꿀 수 있습니다.지금 유효하지 않은 id로 /product API를 요청하면 다음 리스폰스를 받게 됩니다.{ \"timestamp\": \"2020-11-29T09:42:12.287+00:00\", \"status\": 500, \"error\": \"Internal Server Error\", \"message\": \"Item with id 1 not found\", \"path\": \"/product/1\"} 우리가 include-stacktrace를 on_trace_param로 설정한 것을 기억하세요. 이것이 의미하는 바는 url에 trace 파라미터를 포함하는 경우(?trace=true), 리스폰스 페이로드에서 스텍 트레이스를 얻을 수 있다는 것입니다.{ \"timestamp\": \"2020-11-29T09:42:12.287+00:00\", \"status\": 500, \"error\": \"Internal Server Error\", \"message\": \"Item with id 1 not found\", \"trace\": \"io.reflectoring.exception.exception.NoSuchElementFoundException: Item with id 1 not found...\", \"path\": \"/product/1\"} 우리는 적어도 운영 제품에서는 include-stacktrace를 never로 유지하고 싶을 수 있습니다. 우리 어플리케이션의 내부 동작을 들어낼 수 있기 때문입니다.문제는 계속 있습니다! 상태 코드(500)은 서버 코드에서 무언가 이상하다는 것을 가르키지만, 실제로는 클라이언트가 유효하지 않은 id를 전달했기 때문입니다.우리의 현재 에러 메시지 상태 코드는 이런 정보를 정확히 전달하지 않습니다. 불행히도 server.error 설정 속성으로 하는 한 이정도만 적용되므로, 스프링 부트에서 제공하는 어노테이션들을 살펴봐야 합니다.ResponseStatus이름 그대로, @ResponseStatus 응답 리스폰스의 HTTP status를 수정할 수 있게 해줍니다. 아래 위치에 적용 가능합니다. 예외 클래스에서 @ExceptionHanlder 어노테이션을 가진 메서드에서 @ControllerAdvice 어노테이션을 가진 클래스에서이번 섹션에선, 첫번째 경우를 살펴볼 것 입니다.다시 문제상황으로 돌아와보면, 우리 에러 리스폰스는 더 설명적인 status code 대신 항상 HTTP status 500인 것 입니다.이 문제를 해결하기 위해, 우리는 예외 클래스에 @ResponseStatus를 함께 사용하고 value 속성에 원하는 HTTP status를 넣어주면 됩니다.@ResponseStatuspublic class NoSuchElementFoundException extends RuntimeException { ...}만약 우리가 유효하지 않은 id로 controller를 호출한다면, 이 수정사항이 더 나은 리스폰스 가져올 것입니다.{ \"timestamp\": \"2020-11-29T09:42:12.287+00:00\", \"status\": 404, \"error\": \"Not Found\", \"message\": \"Item with id 1 not found\", \"path\": \"/product/1\"} 같은 결과를 만드는 또 다른 방법은 ReponseStatusException 클래스를 상속받는 것입니다public class NoSuchElementFoundException extends ResponseStatusException { public NoSuchElementFoundException(String message){ super(HttpStatus.NOT_FOUND, message); } @Override public HttpHeaders getResponseHeaders() { // return response headers }}getResponseHeaders() 메서드를 오버라이드 할 수 있기 때문에 HTTP header를 조종하려고 할 때 이 접근방법은 유용합니다.하지만 리스폰스 페이로드 구조도 수정하고 싶다면 어떻게 해야할 까요?다음 섹션에서 어떻게 해결할 수 있는지 살펴봅시다.@ExceptionHandler@ExceptionHandler 어노테이션은 예외 처리에 관해서 많은 유연성을 줍니다. 초보자로서 이것을 사용하려면, @ControllerAdvice 클래스나 컨트롤러 자체에서 매서드 하나를 만들면 됩니다. 그리고 그 메서드에 @ExceptionHandler 어노테이션을 붙혀줍니다.@RestController@RequestMapping(\"/product\")public class ProductController { private final ProductService productService; // Constructor omitted for breviy... @Getmapping(\"/{id}\") public Response getProduct(@PathVariable String id) { return productService.getProduct(id); } @ExceptionHandler(NoSuchElementFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ResponseEntity&lt;String&gt; handleNoSuchElementNotFoundException( NoSuchElementNotFoundException exception ) { return ReponseEntity .status(HttpStatus.NOT_FOUND) .body(exception.getMessage()); }}예외 핸들러 메서드는 정의된 메서드에서 다루기를 원하는 예외나 예외 리스트를 인자로 받습니다. 이 메서드를 @ResponseHandler와 @ResponseStatus와 함께 지정해서 우리가 다루기 원하는 예외와 반환하려는 상태코드를 정의합니다.만약 이러한 어노테이션을 사용하고 싶지 않다면, 메서드의 인자로 간단히 정의하는 방법도 똑같이 동작합니다.@ExceptionHandlerpublic ResponseEntity&lt;String&gt; handleNoSuchElementNotFoundexception( NoSuchElementFoundException exception)하지만 메서드 시그니쳐에서 이미 예외 클래스를 정의했지만 어노테이션에 예외 클래스를 정의하는 것은 더 좋은 가독성을 위해 좋은 생각입니다.또한 핸들러 메서드에 ResponseStatus(HTTPStatus.NOT_FOUND) 어노테이션은 ResponseEntity로 전달한 HTTP 상태가 우선되므로 필요 없습니다. 하지만 가독성을 위해 우리는 그대로 두겠습니다.예외처리 파라미터와는 별도로, HttpServletRequest, WebRequest or HttpSession을 파라미터로 받을 수 있습니다.더불어, 핸들러 메서드는 ResponseEntity, String 또는 void처럼 다양한 반환 타입을 지원합니다.더 많은 입력과 반환 타입을 @ExceptionHandler java documentation에서 찾아보세요.예외처리에서 입력과 반환 타입의 형태에 다양한 옵션을 이용 가능하므로, 우리는 에러 응답을 완벽히 제어할 수 있습니다.이제 우리 API의 에러 리스폰스를 완성해봅시다. 어떤 경우에는, 사용자는 두 가지를 기대합니다. 에러 코드는 사용자에게 어떤 종류의 에러인지 알려줍니다. 에러 코드는 클라이언트 단에서 어떤 비지니스 로직을 수행할 지 결정합니다. 대게 에러코드는 표준 HTTP status 코드를 사용하지만, E001처럼 사용자 지정 에러 코드를 반환하는 것도 보았습니다. 에러에 대해 더 많은 정보를 주는 추가적인 인간 친화적 메시지이고 어떻게 고칠지에 대한 힌트와 API 링크입니다.우리는 또 stackTrace 필드를 더하므로써 개발환경에서 디버깅을 도와줄 수 있습니다.마지막으로 우리가 검증 에러에 대해 다루고 싶다면 빈 검증 시스템에 대해 Handling Validations with Spring Boot에서 더 많은 정보를 찾을 수 있습니다.위 상황을 계속 상기하면서 에러 응당에 대해 다음 페이로드를 사용할 것입니다.@Getter@Setter@RequiredArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class ErrorResponse { private final int status; private final String message; private String stackTrace; private List&lt;ValidationError&gt; errors; @Getter @Setter @RequiredArgsConstructor private static class ValidationError { private final String field; private final String message; } public void addValidationError(String field, String message){ if(Objects.isNull(errors)){ errors = new ArrayList&lt;&gt;(); } errors.add(new ValidationError(field, message)); }}이제 이거를 NoSuchElementNotFoundException 핸들러 메서드에 적용해봅시다@RestController@RequestMapping(\"/product\")@AllArgsConstructorpublic class ProductController { public static final String TRACE = \"trace\"; @Value(\"${reflectoring.trace:false}\") private boolean printStackTrace; private final ProductService productService; @GetMapping(\"/{id}\") public Product getProduct(@PathVariable String id){ return productService.getProduct(id); } @PostMapping public Product addProduct(@RequestBody @Valid ProductInput input){ return productService.addProduct(input); } @ExceptionHandler(NoSuchElementFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ResponseEntity&lt;ErrorResponse&gt; handleItemNotFoundException( NoSuchElementFoundException exception, WebRequest request ){ log.error(\"Failed to find the requested element\", exception); return buildErrorResponse(exception, HttpStatus.NOT_FOUND, request); } @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY) public ResponseEntity&lt;ErrorResponse&gt; handleMethodArgumentNotValid( MethodArgumentNotValidException ex, WebRequest request ) { ErrorResponse errorResponse = new ErrorResponse( HttpStatus.UNPROCESSABLE_ENTITY.value(), \"Validation error. Check 'errors' field for details.\" ); for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) { errorResponse.addValidationError(fieldError.getField(), fieldError.getDefaultMessage()); } return ResponseEntity.unprocessableEntity().body(errorResponse); } @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResponseEntity&lt;ErrorResponse&gt; handleAllUncaughtException( Exception exception, WebRequest request){ log.error(\"Unknown error occurred\", exception); return buildErrorResponse( exception, \"Unknown error occurred\", HttpStatus.INTERNAL_SERVER_ERROR, request ); } private ResponseEntity&lt;ErrorResponse&gt; buildErrorResponse( Exception exception, HttpStatus httpStatus, WebRequest request ) { return buildErrorResponse( exception, exception.getMessage(), httpStatus, request); } private ResponseEntity&lt;ErrorResponse&gt; buildErrorResponse( Exception exception, String message, HttpStatus httpStatus, WebRequest request ) { ErrorResponse errorResponse = new ErrorResponse( httpStatus.value(), exception.getMessage() ); if(printStackTrace &amp;&amp; isTraceOn(request)){ errorResponse.setStackTrace(ExceptionUtils.getStackTrace(exception)); } return ResponseEntity.status(httpStatus).body(errorResponse); } private boolean isTraceOn(WebRequest request) { String [] value = request.getParameterValues(TRACE); return Objects.nonNull(value) &amp;&amp; value.length &gt; 0 &amp;&amp; value[0].contentEquals(\"true\"); }}고려해야할 사항들을 여기에 말해보겠습니다.스택 트레이스 제공스택 트레이스를 제공하는 것은 개발자와 QA 엔지니어가 로그파일을 살펴보는 시간을 구할 수 있습니다. 스프링 기본 예외 처리 메커니즘에서 본 것처럼 스프링은 이미 우리에게 기능을 제공합니다. 하지만 이제 에러 응답을 직접 다룬 것 처럼 이것도 직접 다뤄지길 필요가 있습니다.그러기 위해, refactoring.trace 서버-사이드 속성을 소개할 것입니다. 이것은 true로 설정되면 응답에서 stackTrace를 필드를 제공합니다. 실제로 API에서 stackTrace를 얻기 위해서는 클라이언트는 추가적으로 trace 파라미터를 true로 보내야 합니다.curl --location --request GET 'http://localhost:8080/product/1?trace=true이제는 stackTrace의 기능은 우리 속성 파일의 기능 플래그에 의해 제어되므로 우리는 그것을 운영 환경에서는 삭제하거나 false로 설정할 수 있습니다.모든 에러 잡기Gotta catch em all:try{ performSomeOperation();} catch(OperationSpecificException ex){ //...} catch(Exception catchAllExcetion){ //... }예방조치로 우리는 때때로 원하지 않는 부작용이나 기능을 피하기 위해, 상위 메서드를 모든 에러를 잡는 블럭으로 감쌉니다. 우리 컨트롤러에서 handleAllUncaughtException() 메서드는 비슷하게 동작합니다. 이것은 우리가 특정한 메서드가 연결되지 않은 모든 예외를 잡습니다.여기서 말하고 싶은 한가지는 우리가 만약 이 메서드를 사용하지 않더라도 스프링이 모든 예외를 처리할 것입니다. 하지만 우리는 응답 형식이 스프링의 형식보다는 우리 형식을 따르기를 원하기 때문에 이 메서드를 정의해야 합니다.이 메서드는 가능한 버그에 대해 통찰을 제공하는 예외를 로깅하는데 좋은 곳입니다. MethodArgumentNotValidException같은 검증 예외는 스킵할 수 있습니다. 왜냐하면 문법적으로 유효하지 않은 입력에 의해 생기기 때문입니다. 하지만 예상치 못한 예외는 이 catch-all 핸들러 에서 로깅해야합니다.예외 처리의 순서예외를 처리하는 순서는 중요하지 않습니다. 스프링은 첫번째로 해당 에러와 가장 일치하는 핸들러 메서드를 찾습니다.만약 찾지 못한다면 부모 클래스의 핸들러를 찾습니다. 우리 경우에는 RuntimeException이 되겠죠. 그리고 아무것도 찾지 못한다면, hhandleAllUncaughtException() 메서드가 최종적으로 예외를 처리할 것입니다.이건 우리가 특정 컨트롤러 안에서 예외 처리를 다룰 때 도움이 될 것입니다. 그런데 똑같은 예외가 다른 컨트롤러에서 발생한다면 어떨까요? 이것을 어떻게 처리해야 할 까요? 우리는 같은 핸들러 메서드를 모든 컨트롤러에서 만들어야 할까요? 아니면 공통 핸들러 메서드를 가진 부모 클래스를 만든 다음 모든 클래스에서 이것을 상속해야할 까요?운이 좋게도 이렇게 하지 않아도 됩니다. 스프링은 “controller advice”의 형태로 매우 우아한 해결책을 제공합니다.@ControllerAdvice 왜 ControllerAdvice 일까? ‘Advice’라는 말은 AOP에서 나온 말입니다. 이 AOP는 Aspect-Oriented Programming이라고 메서드들에 횡단 코드로 주입(Advice)할 수 있는 기법이다. ControllerAdivce는 우리의 예외 처리 경우에서 중간에 끼어들어 컨트럴로 메서드들의 반환 값을 수정할 수 있게 해줍니다.ControllerAdivce는 우리가 예외 핸들러를 우리 어플리케이션의 하나 이상 또는 모든 클래스에 적용할 수 있게 해줍니다.@ControllerAdvicepublic class GlobalExceptionHandler extends ResponseEntityExceptionHandler { public static final String TRACE = \"trace\"; @Value(\"${reflectoring.trace:false}\") private boolean printStackTrace; @Override @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY) protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid( MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request ) { //Body omitted as it's similar to the method of same name // in ProductController example... //..... } @ExceptionHandler(ItemNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ResponseEntity&lt;Object&gt; handleItemNotFoundException( ItemNotFoundException itemNotFoundException, WebRequest request ){ //Body omitted as it's similar to the method of same name // in ProductController example... //..... } @ExceptionHandler(RuntimeException.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ResponseEntity&lt;Object&gt; handleAllUncaughtException( RuntimeException exception, WebRequest request ){ //Body omitted as it's similar to the method of same name // in ProductController example... //..... } //.... @Override public ResponseEntity&lt;Object&gt; handleExceptionInternal( Exception ex, Object body, HttpHeaders headers, HttpStatus status, WebRequest request) { return buildErrorResponse(ex,status,request); }}@ExceptionHanlder쳅터에서 보여준 코드와 거의 비슷하기 때문에 핸들러 메서드와 그 외 다른 메서드의 바디 부분은 생략되었습니다. 깃헙 레포지토리 GlobalExceptionHanlder class에서 전체 코드를 보실 수 있습니다.잠시후 우리가 얘기할 새로운 것들이 있습니다. 하나의 큰 차이점은 이 핸들러는 ProductController에 국한되지 않고 어플리케이션의 모든 컨트롤러에서 발생하는 에러를 처리합니다.만약 우리가 선택적으로 ControllerAdvice의 영역을 특정 컨트롤러나 패키지에 제한하고 적용하고 싶다면, 우리는 어노테이션에서 제공되는 프로퍼티를 사용할 수 있습니다. @ContollerAdvice(“com.reflectoring.controller”): 우리는 패키지의 이름이나 패키지 이름 리스트를 어노테이션의 value나 basePackages에 전달 할 수 있습니다. ControllerAdvice는 해당 패키지 컨트롤러의 예외만 처리합니다. @ControllerAdvice(annotations = Advised.class): 오직 @Advised 어노테이션된 클래스의 예외만 ControllerAdvice에 의해 처리될 것 입니다.@ControllerAdvice 어노테이션 문서에서 다른 파라미터를 찾아보세요.ResponseEntityExceptionHanlderResponseEntityExceptionHanlder는 ControllerAdvice의 편리한 기본 클래스입니다. 이것은 내부 스프링 예외를 위해 예외처리를 제공합니다. 만약 우리가 이것을 상속하지 않는다면, 모든 예외는 ModelAndView를 반환하는 DefaultHandlerExceptionResolver로 리다이렉트 됩니다. 우리는 우리의 에러 응답을 만드는 것이 목표이기 때문에 이렇게 하지 않겠습니다.보시다시피, 우리는 ResponseEntityExceptionHandler의 두가지 메서드를 오버라이드하고 있습니다. handleMethodArgumentNotValid(): @ExceptionHandler 쳅터에서는 이것을 바로 구현했습니다. 여기서는 단지 이것의 기능을 재정의했습니다. handleExceptionInternal(): ResponseEntityExceptionHandlerd의 모든 핸들러가 우리의 buildErrorReponse()처럼 ReponseEntity를 만들기 위해 이 함수를 사용합니다. 만약 이것을 오버라이드하지 않는다면 클라이언트는 응답 헤더에 Http 상태를 받을 수 있을 것입니다. 하지만 우리는 응답 바디에 Http 상태를 포함하기를 원하니까 이 메서드를 오버라이드했습니다. NoHandlerFoundException를 처리하는 것은 몇 가지 추가 단계가 더 필요합니다. 이 에외는 우리의 시스템에 존재하지 않는 API를 요청하는 경우 일어납니다. ResponseEntityExceptionHandler 클래스를 통해 이 핸들러를 정의해도 이 에외는 DefaultHandlerExceptionResolver로 리다이렉트 됩니다.우리 advice로 리다이렉트 시키기 위해서는 우리 속성 파일에서 몇 가지 속성을 설정해줘야합니다: spring.mvc.throw-exception-if-no-handler-found=true과 spring.web.resources.add-mappings=falsecredit: Stackoverflow user mengchengfeng@ControllerAdvice를 사용하면서 몇 가지 고려해야할 점 단순하게 유지하는 방법은 항상 프로젝트에 오직 하나의 advice 클래스를 가지는 것입니다. 어플리케이션에 모든 예외의 하나의 레포지토리를 갖는 것은 좋은 방법입니다. 많은 ControllerAdvice를 만드는 경우, 어떤 Controller에서 발생한 예외를 처리할지 명확하게 하기 위해 basePackages와 value를 사용하세요. 우리가 @Order 어노테이션으로 어노테이션을 추가하지 않는 한 스프링은 어떤 순서로든 controller advice를 처리할 수 있습니다. 그래서 만약 여러 개의 controller advice가 있다면 catch-all 핸들러를 작성할 때 주의하세요. 특히 어노테이션에 특정한 basePackage나 value를 지정하지 않았을 때 더욱 주의하세요어떻게 스프링은 예외를 처리하나?이제 우리는 스프링에서 우리가 예외를 처리할 수 있는 매커니즘에 대해 설명했습니다. 어떻게 스프링이 처리하는지와 언제 한 매커니즘이 다른 매커니즘보다 우선시 되는지 짧게 이해해봅시다. 우리가 우리 자신의 예외 처리 핸들러를 만들지 않은 경우 예외 처리의 과정을 추적한 아래에 플로우 차트를 봅시다.결론예외가 컨트롤러의 경계를 넘어설 때 이 예외는 JSON 포멧이나 HTML 웹 페이지 형태로 클라이언트로 도달할 예정입니다.이 게시글에서는, 어떻게 스프링이 이러한 예외를 우리 사용자들을 위해 사용자 친화적인 결과로 바꿀 수 있는지와 우리가 원하는 형식으로 더 성형할 수 있는 어노테이션에 대해 보았습니다.읽어주셔서 감사합니다!" }, { "title": "JVM의 구조와 GC", "url": "/posts/jvm/", "categories": "java", "tags": "java, gc, garbege collector, jvm, soft refrence, stong reference, weak reference, phantom reference, young area, old area, perm area, serial gc, parallel gc, parallel old gc, cms gc, g1 gc", "date": "2021-12-19 21:09:00 +0900", "snippet": "JVM 구조JVM은 자바 바이트 코드를 실행할 수 있는 주체이고 일반적으로 인터프리터나 미리 기계어로 만들어 놓는 방식인 JIT(Just in Time) 방식으로 다른 컴퓨터 위에서 바이트 코드를 실행할 수 있도록 만들어 놓은 프로그램 또는 하드웨어이다. 운영체제에 상관없이 JVM위에서 같은 동작이 구동되게 보장하고 GC와 같은 메모리 관리와 클래스 로더를 통해 명령을 실행한다.위 그림은 자바를 컴파일하고 JVM이 실행하는 흐름을 도식적으로 표현한 것이다. 사용자 코드를 jdk에 포함되어 있는 javac가 자바 소스를 컴파일해 자바 바이트코드를 만들고 클래스 로더가 읽어들여 JVM의 실행이 시작된다. 외부에서 JVM의 코드를 이용할 때는 Java Native Interface를 통해 상효작용한다. 프로그램 실행을 위해 필요한 구성요소인 Runtime Data Areas 중 PC Register, JVM stack, Native Method Stack은 쓰레드마다 생성되고 Heap과 Method Area는 공유한다. Runtime Data Areas의 각 요소를 하나씩 알아보자Method AreaJVM이 시작될 때 생성되며 클래스와 인터페이스의 런타임 상수 풀, 필드와 메서드 코드, static 변수 등을 보관한다.Heap객체를 생성하면 메모리 할당이 이루어지는 곳이다. 메서드 영역에 로드된 클래스만 생성이 가능하고 GC에 의해 참조되지 않는 객체를 확인 후 제거하는 작업이 이루어진다.PC Register쓰레드가 어떤 부분을 무슨 명령어로 실행해야할 지에 대한 정보를 가지고 있고 현재 수행중인 쓰레드 명령의 주소를 가지고 있다.JVM Stack메서드를 호출하면 리턴 주소, 지역 변수, 매개 변수, 메소드 정보, 연산 중 필요한 임시 데이터를 저장하는 곳이다.Native Method StackNative Method가 호출되면 쌓이는 곳이다. 일반적인 자바 Method가 호출되면 JVM Stack에 쌓이지만 네이티브 방식의 메서드(C/C++ 형태)가 불려진다면 여기 Native Method Stack에 쌓인다.Garbage Collector메모리 관리 기법 중 하나로, 필요없게 된 메모리 영역을 해제하는 기능이다. 단계적으로 Mark, Sweep 그리고 Compact로 나뉘어진다.Mark &amp; Sweep &amp; Compact Mark: 필요한 객체인지 필요하지 않은 객체인지 대략적으로 구별하고 표시는 단계, 이 객체가 미래에 필요한지는 알 수 없으므로 Reference로 닿을 수 없는 객체를 필요하지 않은 객체로 정의한다. Sweep: Mark된 객체를 해제하고 반환하는 과정 Compact: 제거된 객체때문에 생긴 빈공간을 정리하여 없애는 과정Mark by Reference닿을 수 없는 객체를 찾을 때 JVM Stack과 Native Method Stack 그리고 Method Area에 있는 참조를 root로 해서 닿을 수 없는 객체를 찾는다. 닿을 수 있는 객체를 Reachable 객체, 없는 객체를 UnReachable 객체라고 정의하고 참조하는 객체를 Reference Object, 이 객체에 의해 참조되는 객체를 Referent라고 정의한다.사용자 레벨 코드에서 이 Reference를 변경할 수 없어 GC에 사용자 코드가 관여할 수 없었다. 하지만 Java 1.2부터 java.lang.ref패키지를 추가해 soft, weark, phantom 3가지 방식의 레퍼런스를 사용할 수 있게 되었다.Strong Reference new 연산자로 참조값을 생성하거나 참조값을 변수에 대입하면 Strong Reference로 참조된다. 참조를 타고가다가 닿을 수 있으면 Strongly Reachable 객체로 구분한다. root set으로 부터 시작해서 어떤 reference object도 중간에 끼지 않은 상태로 참조 가능한 객체로 정의한다.Soft Reference root set으로 부터 시작해서 Strongly Reachable객체가 아닌 객체 중에서 Weak Reference, Phantom Reference없이 Soft Reference가 있는 참조 사슬이 하나라도 있는 객체를 Sofly Reachable 객체로 정의한다. Softly Reachable객체는 아래 식에 의해 GC를 수행로 때 제거 여부를 결정한다. (마지막 strong reference가 GC된 때로부터 지금까지의 시간) &gt; (옵션 설정값 N) * (힙에 남아있는 메모리 크기) 옵션 N은 아래처럼 JVM을 실행할 때 줄수있다. 옵션 설정이 낮을 수록 메모리 회수 속도가 빨라진다. -XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt; Weak Reference root set으로 부터 시작해서 Strongly Reachable, Softly Reachable 객체가 아니고 Phantom Reference없이 Weak Reference가 있는 참조 사슬이 하나라도 있는 객체를 Weakly Reachable객체로 정의한다. Weakly Reachable객체는 매 GC마다 제거된다. 매 GC때마다 삭제되도 되는 캐시같은 경우 사용한다.Phantom Reference Finalize 이후의 작업을 처리할 때 사용한다. 참조값을 null로 만드는 clear()를 명시적으로 불러줘야한다. Finalize 작업은 GC에 따라 실행이 안될 수 있고 예외가 발생되면 무시되서 ReferenceQueue에서 지워진 Reference에 대한 후처리 작업을 해준다.GC의 처리 순서는 아래와 같다 Soft References Weak References Finalize Phantom References 메모리 회수Phantom References에 대한 처리는 Finalize 이후에 처리된다. Soft, Weak References는 객체 내의 참조를 null로 바꾼 뒤 ReferenceQueue에 enqueue되지만 Phantom References는 발견되자마자 Finalize 이후 ReferenceQueue에 넣어진다. 사용자 코드에서 이 ReferenceQueue에 접근해 후처리 작업을 할 수 있으며 clear() 메서드를 통해 참조를 null로 만들어 주어야한다.GC 알고리즘GC는 Heap에서 메모리 관리를 위해 일어나며 Mark -&gt; Sweep -&gt; Compact순으로 일어난다.Heap 메모리 구조힙영역은 Young 영역과 Old 영역과 Perm 영역으로 나뉘어진다. 그리고 Young 영역은 Eden과 두 개의 Survivor영역으로 나뉘어진다. 새로 생성되는 객체는 대부분 Eden영역에 할당된다. 할당될 때 bump-the-pointer와 TLABs(Thread-Local Allocation Buffers)라는 기술이 쓰이는데 bump-then-pointer는 마지막으로 할당된 객체의 참조를 가지고 있어서 새로운 메모리 할당이 일어날때 신속하게 사이즈 체크와 할당이 이루어진다. TLABs는 여러 쓰레드가 동시에 할당하려고 할 때 안정성에 문제가 있으므로 각 쓰레드마다 Eden영역을 나눠가질 수 있게 만든 것이다.Young 영역의 구성과 GCYoung영역은 Eden과 두 개의 Survivor영역으로 구성되고 Minor GC로 메모리 관리를 한다. Eden 영역에서 GC가 발생한 후 살아남은 객체들은 두 Survivor 영역 중 한 곳으로 이동한다. 이 Survivor영역이 가득차게 되면 GC가 동작하고 살아남은 객체들은 다른 Survivor영역으로 이동한다. 몇 번의 반복 후에도 살아남은 객체는 Old 영역으로 이동한다. Old영역으로 넘어가는 기준은 MaxTenuringThreshold 설정값을 통해 조절 가능하다. Minor GC에서도 STW(Stop-The-World)는 일어나고 살아남는 객체가 많을 수록 이동하는 시간이 길어져 STW 시간이 길어진다.GC 알고리즘GC 알고리즘은 JVM 옵션으로 선택할 수 있으며 각 어플리케이션에 맞게 끔 여러 요인을 따져보고 선택해야한다.Serial GC (-XX:+UserSerialGC)Serial GC는 32bit JVM의 기본값이며 타겟 플랫폼의 CPU 코어 수가 적은 경우 유리하다. 하나의 쓰레드가 Mark, Sweep, Compact하는 방법이다.Parallel GC (-XX:+UseParallelGC)Serial GC를 병렬로 처리해 STW 시간을 줄인 방법이다.Parallel Old GC(-XX:+UseParallelOldGC)위 과정과 비슷하지만 Old 영역의 GC가 Mark -&gt; Summary -&gt; Compact 과정을 거친다. Summary 단계는 Sweep 단계와 다르게 여러 쓰레드가 동시에 훑는다고 한다. 그리고 앞선 GC에서 Compact된 영역도 별도로 훑는다.CMS GC (-XX:+UseConcMarkSeepGC)각 단계를 나눠 중간에 다른 작업을 할 수 있게 끔 만든 것이다. STW 시간을 줄였으며 초기 root set을 찾는 과정인 Initial Mark와 Concurrent Mark 도중 생기는 객체를 위해 수행하는 Remark 이 두 단계에서만 STW가 일어난다.G1 GCG1 GC는 Young 영역과 Old 영역이 나뉘어져 적용되던 위 4가지 방법과 다르게 메모리를 구역별로 나눠 해당 영역이 가득 차면 다른 영역에 객체를 할당하고 GC를 수행하는 방식이다. 위 4가지 방법과 비교했을 때 가장 빠르다.다음은 GC 모니터링과 튜닝 방법인터넷에 돌아다니는 정보들을 찾아보고 정리해보았는데요. 궁금한 것에 대해 찾아보려해도 자세한 내용을 설명하는 글은 많지 않네요. 관리 툴을 사용해보면서 직접 메모리를 보며 실전 경험으로 알아가야 할 거 같습니다. 😅 다음 포스팅은 GC 모니터링과 튜닝 방법에 대해 공부하고 정리할게요!참고 자료 네이버 D2: Java Garbage Collection 네이버 D2: Java Reference와 GC Java Phantom Reachable, Phantom Reference 란 JAVA GARBAGE COLLECTION HANDBOOK" }, { "title": "자바스크립트 동작 원리에대한 개념 정리", "url": "/posts/javascript-execution-concepts/", "categories": "javascript", "tags": "javascript, v8, webassembly, node.js, garbege collector, gc, event loop, single thread", "date": "2021-12-12 23:45:00 +0900", "snippet": "시작하며이번에는 자바 런타임에서 바이트코드를 실행할 수 있는 JVM(Java Virtual Machine)과 Javascript 엔진인 V8에 대해 비교하며 살펴보려고 합니다. 개발하다 보면 많이 듣는 용어고 의미정도는 어렴풋이 알고 있긴 하지만 설명을 하라고 하면 못할 거 같습니다.. 😓 그래서 이번엔 V8과 JVM에 대해 정리하고 관련된 용어(Node.js, ECMAScript, JDK, GC)도 공부해보려고 합니다. 잘못된 정보나 제 말에 억측이 있어 짚어주신다면 고맙겠습니다~ 😊V8 엔진에 대해서V8 개발자 사이트(v8.dev)에 접속하면 아래와 같이 V8을 말하고 있다. V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js, among others. It implements ECMAScript and WebAssembly, and runs on Windows 7 or later, macOS 10.12+, and Linux systems that use x64, IA-32, ARM, or MIPS processors. V8 can run standalone, or can be embedded into any C++ application.정리하면 C++로 구현된 Javascript와 WebAssembly 엔진이고 ECMAScript의 구현체이다. 또한 여러 플랫폼 위에서 standalone 방식으로 실행될 수 잇고 C++ 임베디드 환경에서도 사용 가능하다. Javascript는 익숙한데 WebAssembly는 무엇일까? WebAssembly는 스택기반 가상환경에서 실행할 수 있는 바이너리 코드 포맷이다. 웹의 브라우저나 서버에 배포할 수 있도록 포터블하게 디자인 되어있다. 쉽게 말하면, C나 C++로 프로그래밍한 결과를 브라우저에서 실행시켜주는 기술이다. 장점으로는 빠르고 효과적인 실행이 있다. 네이티브 어플리케이션의 속도를 목표로 한다고 한다. 또한 웹 플랫폼의 일부분으로서 Javascript에서 실행될 수 있고 역으로 Javascript를 실행할 수 도 있다. 더 알고 싶다면 webassembly를 참고하자. 어쨋든 V8엔진은 Javascript뿐만 아니라 WebAssembly도 포함한 엔진이다.ECMAScript는 Ecma International(국제 정보 통신 시스템 국제화 기구)이 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어이다. 자바스크립트를 표준화하기 위해 만들어 졌고 액션스크립나 J스크립트 등 다른 구현체도 있다. Node.js같이 서버 응용 프로그램에도 쓰이고 있다. 쉽게 말하면 자바스크립트를 표준화시킨 규격이다.V8 엔진 구조프런트엔드 코드를 작성하면서 알 필요는 없지만 항상 궁금했다. C나 C++은 학교 교수님이 어떻게 어셈블리어로 바뀌고 실행이 되는지 자세하진 않지만 설명을 들었고 그 만큼 코드가 어떻게 동작할지 예상이 되었다. V8 엔진에 대해서도 대략적으로나마 알아보자V8은 내연 기관에 들어가는 8기통 엔진에서 유래되었다고 한다. 각 크랭크실에 가스를 분사한 후 점화를 일으켜 피스톤이 운동에너지를 전달한다. 과열된 엔진은 그릴에서 들어오는 바람이나 팬으로 냉각한다. 자바스크립트 엔진인 V8에서도 비슷한 내부 로직이 보인다. V8의 parser는 자바스크립트 소스를 읽어 들여 AST(추상 문법 트리)로 만든다. 그리고 Interpreter Ignition으로 byteCode를 만들어 실행할 수 있게 점화한다. 어떤 코드가 유난히 많이 실행이 되면 TurboFan이 코드 최적화를 시켜 엔진의 속도를 높인다. 더 자세히 알면 좋지만 byteCode나 TurBoFan이 어떻게 최적화 하는지는 나중에 찾아보기로 한다.가비지 컬렉터(GC)C와 같은 저수준 언어에서는 프로그래머가 명시적으로 메모리의 할당과 해제를 수행하지만 자바스크립트 같은 고수준 언어는 객체가 생성되었을 때 자동으로 메모리를 할당하고 필요없을 때 해제한다. 하지만 이런 메모리 관리가 개발자에게 메모리 관리에 대한 고민을 완전히 없애고 신경쓰지 않아도 된다는 것은 아니다. 메모리의 생명주기는 언어에 관계없이 대부분 아래와 같다. 메모리 생성 사용한다. 필요없어지면 해제한다.3번에서 대부분의 문제가 발생한다. 언제 필요없어지는지 알수가 없기 때문이다. 어떤 메모리가 여전히 필요한지 아닌지를 판단하는 것은 비결정적 문제이기 때문이다. 따라서 가비지 컬렉터(GC)는 제한적인 해결책을 제시한다. 참조-세기(Reference-counting) 가비지 컬렉션 단순한 알고리즘이다. 더 이상 필요없는 오브젝트를 어떤 다른 오브젝트도 참조하지 않는 오브젝트라고 정의한다. 다시말하면 자신 또는 자신의 속성을 참조하는 변수가 없는 오브젝트는 삭제하는 것이다. 하지만 아래와 같은 순환 참조에서는 스코프를 벗어나 객체가 메모리에서 회수되어야 하지만 회수되지 않는다. 참조-세기 가비지 컬렉터에서 메모리 누수의 흔한 원인이다.function f() { var x = {}; var y = {}; x.a = y; y.a = x; return \"oopty!\";}f();자기 자신의 속성이 자신을 참조하는 경우도 순환참조라고 볼 수 있다. 표시하고-쓸기(Mark-and_sweep) 알고리즘이 알고리즘은 더 이상 필요없는 오브젝트를 닿을 수 없는 오브젝트로 정의한다. roots라는 오브젝트 집합을 가지고 있고 주기적으로 가비지 컬렉터는 roots에서 시작하여 참조할 수 있는 오브젝트를 닿을 수 있는 오브젝트라고 표시한다. 그리고 닿을 수 없는 오브젝트들에 대해 가비지 컬렉터를 수행한다.이는 참조-세기 알고리즘보다 효율적이다. 즉 더 많은 오브젝트의 메모리를 해제한다. 왜냐하면 참조하지 않는 오브젝트는 모두 닿을 수 잇는 오브젝트이지만 역은 성립하지 않기 때문이다. 반례로 순환 참조하는 오브젝트를 들수있다. 2012년 기준으로 모든 최신 브라우저는 표시하고-쓸기(Mark-and-sweep) 알고리즘을 사용한다고 한다. 수동 메모리 해제2019년 기준으로 자바스크립트는 메모리 해제를 명시적으로 할 수 없다. 힙 메모리 사용량 늘리기node --max-old-space-size=6000 index.js 가비지 수집기 디버깅node --expose-gc --inspect index.js이벤트 루프자바스크립트는 ‘단일 스레드’기반의 언어다. 하지만 브라우저를 사용해 보면 렌더링을 하는 동시에 HTTP request도 보내고 setTimeout으로 콜백을 전달하기도 한다. 이러한 동작은 단일 스레드에서 어떻게 수행하는 것일까? 즉, 자바스크립트의 동시성(Concurrency)는 어떻게 동작하는 것일까?이벤트 루프는 V8엔진에 있는 것이 아니라 비동기 I/O를 지원하는 멀티 플랫폼 C라이브러리인 LibUV에 있다. 자바스크립트의 규격인 ECMAScript에는 이벤트 루프나 비동기에 관련된 언급이 없다고 한다. libUV가 있기 때문에 자바스크립트에서 동시성을 사용할 수 있는 것이다.총 7개의 페이즈가 있고 각 페이즈마다 특정 역할이 있다. 각 페이즈는 큐를 가지고 있고 자바스크립트는 idle과 prepare을 제외하고 실행될 수 있다.Timer Phase이벤트 루프의 시작이고 타이머들의 콜백을 min heap에 가지고 있다가 시간이 지나면 해당 타이머를 큐에 넣고 실행한다.Pending i/o callback phasepending_queue에 들어가 있는 콜백을 실행한다. poll phase에서 pending된 i/o 콜백을 실행하는 거 같다.Idle, Prepare pahse이름은 Idle Phase이지만 이 페이즈는 매 tick마다 실행한다. Node.js의 내부관리를 위해 사용하는 것이다.Poll phase새로운 수신 커넥션과 데이터 읽기/쓰기 등 대부분의 콜백을 실행한다. watch_queue가 비어있지 않다면, 큐가 비거나 시스템 최대 실행 한도에 다다를때까지 동기적으로 콜백을 실행, 비어있다면 Check phase 로 넘어가거나 약간의 대기시간을 가지게 되고 타이머 min heap에서 하나를 꺼내고 타이머가 실행 가능한 상태면 타이머의 딜레이 시간만큼 대기한다.Check phasesetImmediate() API의 콜백을 큐가 비거나 실행 한도가 초과될 때까지 실행한다.Close Callback커넥션을 닫거나 종료하는 콜백을 실행한다.nextTickQueue &amp; microTaskQueue다음 페이즈로 넘어가기 전에 두 큐에 있는 콜백을 높은 우선순위로 실행한다. nextTickQueue가 microTaskQueue보다 높은 우선순위를 가지고 있다.마치면서프로그래밍을 하면서 그냥 지나쳤던 자바스크립트의 동작 원리에 대해 간단히 정리해 보았습니다. 대략적인 개념 정도로 정리했고 자세한 내용은 포스팅 하나하나로 정리해야 할 거 같습니다. 특히 이벤트 루프관련된 내용이 자바스크립트 실행 순서와 관련된 내용이라서 꼭 한번 정리하겠습니다.참고자료 Evans Library: 로우레벨로 살펴보는 Node.js 이벤트 루프 NHN Cloud MeetUp: 자바크립트와 이벤트 루프 MDN Web Docs: 동시성 모델과 이벤트 루프 MDN Web Docs: 자바스크립트의 메모리관" }, { "title": "함수형 프로그래밍의 의미와 장점", "url": "/posts/java-study1/", "categories": "java", "tags": "stream, concurrency, parallelism, short curcuit, functional programming, mathmetical function, lambda, java", "date": "2021-11-15 23:45:00 +0900", "snippet": "자바 8, 9, 10에 대한 책을 읽으면서 함수형 프로그래밍에 대해 알게 된 것과 느낀 것을 정리하려고 합니다. 개인적인 참고 용도와 저처럼 초보 개발자들을 위해 적겠습니다.😀함수형 프로그래밍이란 무엇일까?자바에서는 stream, map, filter등 많은 것들이 떠오르겠지만 위키피디아에서는 아래와 같이 정의한다. 함수형 프로그래밍(函數型 프로그래밍, 영어: functional programming)은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다나머지 단어는 알겠는데 “수학적 함수의 계산”이란 무엇일까? 명령형 프로그래밍에서 다루는 함수는 수학에서 정의하는 함수와 다르다. 수학적 함수는 매번 같은 입력이 주어질 때마다 같은 출력이 나오지만 명령형 프로그래밍은 아래와 같이 상태의 값을 꿔 부작용(side effect)이 생겨 매번 출력이 다르게 나올 수 있다.class Main() { private int total = 0; public static void main(String[] args) { System.out.println(add(1)); // 1 System.out.println(add(1)); // 2 } private add(int num) { // total의 상태를 바꾸고 있고 그에 따라 결과가 매번 바뀜 total += num; return total; }반면 아래와 같은 함수는 수학적 함수라고 볼 수 있다.class Main() { private int total = 0; public static void main(String[] args) { System.out.println(add(1, 1)); // 2 } private add(int num1, int num2) { // 상태를 바꾸지 않음 return num1 + num2; }}수학적 함수를 사용하면 자연스럽게 상태와 가변 데이터를 멀리하는 코드가 나올 수 밖에 없다. 이렇게 함수형 프로그래밍은 상태와 가변 데이터를 멀리하게 끔 수학적 함수로 코드를 짜는 프로그래밍 종류 중 하나다. 그러면 함수형 프로그래밍을 통해 얻는 이점은 무엇일까?코드 이해가 쉽다 (강력한 추상화)함수형 프로그래밍은 부작용이 없는 것이 보장되어 결과만 생각하며 코드를 읽을 수 있고 또한 내부 로직을 타고 들어가지 않아도 함수 이름으로 결과를 유추할 수 있다.병렬 프로그래밍을 짜기가 쉽다가변 데이터를 건드리지 않으므로 동시성 프로그래밍에서 생각할 것이 줄어든다. 쓰레드가 한 자원을 공유해서 쓰면서 상태를 바꾸면 예상치 못한 버그가 나올 수 있다. 하지만 상태를 바꾸지 않는 함수형 프로그래밍에서는 여러 스레드가 해당 데이터에 동시에 접근하더라도 데이터가 변경되지 않는 것을 보장하기 때문에 레이스 컨디션에 대한 버그는 나올 수 없다.쇼트 서킷과 최적화함수형 프로그래밍이기 보다는 자바의 Stream과 관련 메서드에 관한 장점이지만 어차피 자바를 공부하는 것이기 때문에 얘기한다😙 Stream으로 Collection을 처리하면 명령형 프로그래밍으로는 귀찮은 여러가지 최적화를 해준다.Lazy Evaluation함수형 프로그래밍은 어떻게 할지(How)보다 무엇을 할지(What)을 정의한다. 그래서 Stream을 사용할 때 중간연산으로 무엇을 할지를 정의하고 마지막 최종 연산으로 계산을 한다. 이렇게 게으르게 계산을 해서 얻는 최적화가 있다.Short Curcuit쇼트 서킷은 처리하지 않아도 되는 것은 처리하지 않는 최적화다. 예를 들어 조건문에서 &amp;&amp; 앞에가 False이면 뒷 문장은 실행하지 않고 || 앞에가 True이면 뒷 문장은 실행하지 않는다. Stream에서도 비슷한 최적화가 적용된다.public class Main { public static void main(String[] args) { List&lt;Integer&gt; list = List.of(1,2,3,4,5,6,7,8,9,10); list.stream().map(i -&gt; { System.out.println(i) // 5번만 실행됨 return i; }).limit(5).toList(); }}위 코드에서 요소를 5개까지 제한하는 limit 함수 때문에 5 이후에 값은 볼 필요가 없으므로 5까지 출력이되고 나머지 요소는 출력되지 않는다.중간연산의 동시적으로 실행파이프라인으로 연결된 함수들이 동시에 실행이된다.public class Main { public static void main(String[] args) { List&lt;Integer&gt; list = List.of(1,2,3,4,5,6,7,8,9,10); list.stream().map(i -&gt; { System.out.println(\"1번째 map의 \" + i); return i; }).map(i -&gt; { System.out.println(\"2번째 map의 \" + i); return i; }).toList(); }}위 코드를 실행해보면 1번째 map과 2번째 map이 번갈아가며 실행되는 것을 알 수 있다.책을 읽으면서 함수형 프로그래밍이 멀티쓰레드 환경에서 CPU자원을 잘로활용하려면 필수적이라고 느꼈습니다. 현재 많은 컴퓨터가 멀티 코어를 지원하고 직접회로의 한계 때문에 개별 코어의 성능을 높이기 보다는 코어수를 늘리는 방향으로 진화하고 있습니다. 따라서 멀티 코어를 잘 활용할 수 있어야 비지니스 비용을 아낄 수 있을 거 같습니다.🤑 하지만 명령형 프로그래밍에 익숙한 저는 함수형 프로그래밍으로 생각하는게 어렵네요… 다음 번엔 Stream을 사용해서 병렬 프로그래밍하는 방법을 정리하겠습니다!" } ]
