<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://oopty.github.io/</id><title>oopty</title><subtitle>no description, please enter a description</subtitle> <updated>2023-08-26T23:04:11+09:00</updated> <author> <name>oopty</name> <uri>https://oopty.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://oopty.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="custom" href="https://oopty.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 oopty </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Effective Java 정리 Item10 [Eqauls는 일반 규약을 지켜 재정의하라]</title><link href="https://oopty.github.io/posts/effective-java-item-7/" rel="alternate" type="text/html" title="Effective Java 정리 Item10 [Eqauls는 일반 규약을 지켜 재정의하라]" /><published>2023-08-26T09:00:00+09:00</published> <updated>2023-08-26T09:00:00+09:00</updated> <id>https://oopty.github.io/posts/effective-java-item-7/</id> <content src="https://oopty.github.io/posts/effective-java-item-7/" /> <author> <name>oopty</name> </author> <category term="java" /> <summary> eqauls 메서드는 Object 클래스에 정의되어 있고 기본적으로 동일성(identity) 검사를 하게 됩니다. 즉, 가지고 있는 속성(멤버 변수)가 같아도 객체가 다르면 false를 반환한다는 말입니다. 이 Equals를 재정의 할 때는 고려해야할 것이 많고 구현하고 검증 과정을 반드시 거쳐야 하기 때문에 정말 eqauls를 구현해야 하는 것이 맞는지 고민을 해봐야 합니다. 책에서는 아래 4가지를 생각해보고 한 가지라도 해당이 된다면 Eqauls 메서드를 구현하지 말라고 합니다. 각 인스턴스가 본질적으로 고유하다 인스턴스의 ‘논리적 동치성’을 검사할 일이 없다. 여기서 논리적 동치성이란 동등성(eqauilty)를 말한다. 상위 클래스에서 재정의한 eqauls가 하위 클래스에도 딱 들어... </summary> </entry> <entry><title>객체지향의 사실과 오해 책 후기</title><link href="https://oopty.github.io/posts/the-essence-of-object-orientation/" rel="alternate" type="text/html" title="객체지향의 사실과 오해 책 후기" /><published>2023-08-06T09:00:00+09:00</published> <updated>2023-08-06T09:00:00+09:00</updated> <id>https://oopty.github.io/posts/the-essence-of-object-orientation/</id> <content src="https://oopty.github.io/posts/the-essence-of-object-orientation/" /> <author> <name>oopty</name> </author> <category term="Develop Paradigm" /> <summary> 요즘 부서 이동때문에 출퇴근이 4시간이 넘게 걸리네요.. ㅎㅎ 부랴부랴 회사옆에 집은 구했는데 아직 입주까지 2주가 남은 상황이라 조금 더 힘을 내야할듯 합니다. 😅 출퇴근 시간에 읽은 조영호 저자님의 객체지향의 사실과 오해에 대해 후기를 남기려고 합니다. 책 내용 정리보다는 제가 이해한 내용을 바탕으로 글을 쓰려고 합니다. 객체지향 프로그래밍은 우리가 실생활에서 인지하고 있는 객체를 소프트웨어에 투영시킴으로써 기억하기 쉽고 이해하기 쉬운 소프트웨어를 만드는데 초점이 맞춰져있습니다. 하지만 실생활의 객체를 그대로 옮긴 것은 아닙니다. 소프트웨어 세상은 현실에 없는 객체도 존재하고 현실세계에서 대부분의 객체는 자율적인 의지가 없어 스스로 행동할 수 없지만 소프트웨어 세상에서 객체는 의지를 갖고 행동할 ... </summary> </entry> <entry><title>Effective Java 정리 Item6 [불필요한 객체 생성을 피하라]</title><link href="https://oopty.github.io/posts/effective-java-item-6/" rel="alternate" type="text/html" title="Effective Java 정리 Item6 [불필요한 객체 생성을 피하라]" /><published>2023-07-23T09:00:00+09:00</published> <updated>2023-07-23T09:00:00+09:00</updated> <id>https://oopty.github.io/posts/effective-java-item-6/</id> <content src="https://oopty.github.io/posts/effective-java-item-6/" /> <author> <name>oopty</name> </author> <category term="java" /> <summary> Item6에서는 불필요한 객체를 만들어내는 실수에 대해 다룹니다. 예를 들어, new String("bikini")와 "bikini"는 기능적으로 완전히 똑같지만 메모리와 cpu 자원을 낭비합니다. (라고 책에서 말하지만, Java 컴파일러가 잡아서 최적화 시켜줄 거 같습니다 ㅎㅎ) 또한 생성자보단 정적 팩토리 메서드를 사용해서 불필요한 객체 생성을 막는 것도 좋은 습관이 될 거 같습니다. 생성 비용이 비싼 객체는 더욱 중복된 객체가 만들어지는 것에 주의해야합니다. 예를 들어 아래 Pattern객체는 한번 생성될 때 유한 상태 머신도 같이 만들어 지기 때문에 비용이 많이 듭니다. static boolean isRomanNumeralV1(String s) { return s.matches("^... </summary> </entry> <entry><title>Effective Java 정리 Item5</title><link href="https://oopty.github.io/posts/effective-java-item-5/" rel="alternate" type="text/html" title="Effective Java 정리 Item5" /><published>2023-07-23T09:00:00+09:00</published> <updated>2023-07-23T09:00:00+09:00</updated> <id>https://oopty.github.io/posts/effective-java-item-5/</id> <content src="https://oopty.github.io/posts/effective-java-item-5/" /> <author> <name>oopty</name> </author> <category term="java" /> <summary> Item5에서는 정적 유틸리티 클래스나 싱글톤 패턴을 잘못 사용한 예에 대해 설명하면서 의존성 주입을 사용하라고 권고합니다. 예시를 든 코드는 철자 검사기인데 이 철자 검사기 클래스는 정확한 맞춤법이 적혀진 사전을 필드에 가지고 있습니다. 이를 싱글톤이나 유틸리티 클래스로 만들면 하나의 사전만 시스템에서 사용할 수 있습니다. 하지만 현실에선 영어사전도 필요하고, 한국어 사전도 필요한것 처럼 여러 사전이 필요한 상황이 있습니다. 그래서 이 경우에는 싱글톤이나 유틸리티 클래스가 적합하지 않습니다. setter 함수로 바꿔가면서 사용할 수 있지만 이렇게 되면 불변객체가 아니게 되고 멀티 쓰레드 환경에서는 사용하기 어렵습니다. 그래서 처음 객체가 생성될 때 객체를 넘겨 그 객체를 사용하게 만드는 것이 좋습니다... </summary> </entry> <entry><title>Effective Java 정리 Item3</title><link href="https://oopty.github.io/posts/effective-java-item-3/" rel="alternate" type="text/html" title="Effective Java 정리 Item3" /><published>2023-07-23T09:00:00+09:00</published> <updated>2023-07-23T09:00:00+09:00</updated> <id>https://oopty.github.io/posts/effective-java-item-3/</id> <content src="https://oopty.github.io/posts/effective-java-item-3/" /> <author> <name>oopty</name> </author> <category term="java" /> <summary> item3는 싱글톤 객체를 만드는 방법에 대해 설명합니다. 싱글톤으로 만들면 그 객체를 mocking하기 어려워진다고 합니다. 시스템에 하나의 객체밖에 없도록 설계된 클래스라 mock 객체를 만들기 어렵기 때문입니다. 싱글톤 객체를 만드는 방법은 세가지 입니다. 필드 정적 멤버, 메서드 정적 멤버와 열거타입입니다. 필드 정적 멤버 public class ElvisV1 { public static final ElvisV1 INSTANCE = new ElvisV1(); public ElvisV1() { } } 위 방식의 장점은 첫번째로 간단하다는 것입니다. 따로 접근을 위한 메서드가 필요하지 않습니다. 두번째 장점으로 Reflection을 이용하지 않는다면 싱글톤 객체라는 제약사... </summary> </entry> </feed>
